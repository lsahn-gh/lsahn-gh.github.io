[{"body":"","link":"https://www.ooseel.net/me/","section":"","tags":null,"title":""},{"body":"","link":"https://www.ooseel.net/me/posts/","section":"posts","tags":null,"title":""},{"body":"","link":"https://www.ooseel.net/me/tags/arm64/","section":"tags","tags":null,"title":"arm64"},{"body":"esBPF project has been over one year and it began with the idea that Is it worth filtering ingress packets on Software-Offload layer instead of Network Stack? Software-Offload is similar to Hardware-Offload, but it works in ethernet driver. Now time to do Stress-testing since its prototype was released and the comparison object will be iptables.\nBefore walking through the article, let me define a few short terms against typing exhausting long terms,\n   Long Term Short Term     Raspberry Pi 3 Rpi3   Host Machine Host    Testbed Host and Rpi3 are on link connection of the same LAN of the AP below that it supports HW-offload and being Bridge mode against its Kernel interrupts forwarding packets between them.\n1 High-Performance AP 2 - HW-offload Supported 3 - Bridge Mode 4 +-----------------+ 5 | Wireless AP | 6 +-----------------+ 7 100Mbps link | | 1Gbps link 8 +----------+ +-----------+ 9 | | 10+-------------------+ +-------------------+ 11| Raspberry Pi 3 | | Host Machine | 12| (192.168.219.103) | | (192.168.219.108) | 13+-------------------+ +-------------------+ Also using hping3 program for Stress-testing that is going to be just flooding ICMP packets to Rpi3.\n1$ hping3 --icmp --faster 192.168.219.103 -d 20 Tuning Raspberry-Pi 3 for the testing  Ubuntu 22.10 Kinetic Release - Kernel 5.19.0-1007 (Arm64) Enable CONFIG_HOTPLUG_CPU to on/off CPU cores esBPF-based customized eth driver, smsc95xx-esbpf Off wlan0 interface not to mess up routing  It's set up using 2 cores instead of entire CPUs to load up full traffic on a specific number of cores by maxcpus=2 at boot command-line. Hence we have 2 online and offline cores respectively,\n1ubuntu@ubuntu:~$ lscpu 2Architecture: aarch64 3 CPU op-mode(s): 32-bit, 64-bit 4 Byte Order: Little Endian 5CPU(s): 4 6 On-line CPU(s) list: 0,1 7 Off-line CPU(s) list: 2,3 8Vendor ID: ARM 9 Model name: Cortex-A53 Briefing about smsc95xx-esbpf Two significant files exist under a directory /proc/smsc95xx/esbpf once the driver has been loaded on Kernel and each other is responsible for ...\n rx_enable : turns on/off esbpf operations. rx_hooks : is supposed to be written by a program of cBPF instructions.  Stress-testing We are going to look at mpstat values and compare NET_RX in /proc/softirqs before and after executing hping3. Please suppose the program would be running for 60 seconds on Host in each case.\nHere is the idle usage of the CPUs of Rpi3. The idle columns are almost the same in both testing cases, iptables and Software-Offload before generating massive traffic on the LAN.\n1$ mpstat -P ALL 3 2CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 3all 0.00 0.00 0.17 0.00 0.00 0.17 0.00 0.00 0.00 99.66 4 0 0.00 0.00 0.34 0.00 0.00 0.00 0.00 0.00 0.00 99.66 5 1 0.00 0.00 0.00 0.00 0.00 0.34 0.00 0.00 0.00 99.66 1. iptables In the first test, the following rule is supposed to be appended in INPUT part on Rpi3 and as the result, one of the CPUs is being performed by softirq which means so busy to work.\n1$ iptables -A INPUT -p icmp -j DROP 2$ iptables -nvL 3Chain INPUT (policy ACCEPT 0 packets, 0 bytes) 4 pkts bytes target prot opt in out source destination 5 0 0 DROP icmp -- * * 0.0.0.0/0 0.0.0.0/0 6 7# NET_RX softirq count before massive traffic 8 CPU0 CPU1 CPU2 CPU3 9 NET_RX: 123 66 0 0 10 11# NET_RX softirq count after that 12 CPU0 CPU1 CPU2 CPU3 13 NET_RX: 15040 35021 0 0 14 15# mpstat 16CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 17all 0.00 0.00 0.18 0.00 0.00 52.89 0.00 0.00 0.00 46.94 18 0 0.00 0.00 0.37 0.00 0.00 0.74 0.00 0.00 0.00 98.89 19 1 0.00 0.00 0.00 0.00 0.00 100.00 0.00 0.00 0.00 0.00 2. esBPF In the second test, it's going to drop the same type of packets in Software-Offload, in other words, in-driver. Special tools are required for doing that, tcpdump and filter_icmp but the latter already has hard-coded cBPF instructions, so tcpdump ain't necessary at this point.\nThe hard-coded part is as follows\n1struct sock_filter insns[] = { 2 /* tcpdump -dd -nn icmp */ 3 { 0x28, 0, 0, 0x0000000c }, 4 { 0x15, 0, 3, 0x00000800 }, 5 { 0x30, 0, 0, 0x00000017 }, 6 { 0x15, 0, 1, 0x00000001 }, 7 { 0x6, 0, 0, 0x00040000 }, 8 { 0x6, 0, 0, 0x00000000 }, 9}; and the program is executed by the following command that actually tries writing the above instructions to esBPF module.\n1$ sudo ./filter_icmp /proc/smsc95xx/esbpf/rx_hooks 2$ sudo echo 1 \u0026gt; /proc/smsc95xx/esbpf/rx_enable Even though hping3 works in the same flow, NET_RX didn't rise as much as the first case.\n1# NET_RX softirq count before massive traffic 2 CPU0 CPU1 CPU2 CPU3 3 NET_RX: 129 81 0 0 4 5# NET_RX softirq count after that 6 CPU0 CPU1 CPU2 CPU3 7 NET_RX: 141 94 0 0 Also, the average usage of CPUs by softirq is around 8% up to 30% by looking at the best and worst cases respectively.\n1# mpstat in the best case 2CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 3all 0.00 0.00 0.64 0.00 0.00 7.99 0.00 0.00 0.00 91.37 4 0 0.00 0.00 0.65 0.00 0.00 6.54 0.00 0.00 0.00 92.81 5 1 0.00 0.00 0.62 0.00 0.00 9.38 0.00 0.00 0.00 90.00 6 7# mpstat in the worst case 8CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 9all 18.31 0.00 4.58 0.96 0.00 27.47 0.00 0.00 0.00 48.67 10 0 14.50 0.00 4.00 1.00 0.00 26.00 0.00 0.00 0.00 54.50 11 1 21.86 0.00 5.12 0.93 0.00 28.84 0.00 0.00 0.00 43.26 Notice that you may sometimes see a few ICMP packets come to Network Stack although esBPF is enabled. No worries they are just from lo interface.\nConclusion esBPF works on Software-Offload, as known as device driver layer against Netfilter, a superset of iptables which works in Network Stack. Hence it drops all incoming packets matched to the filters in Tasklet level instead of NET_RX (part of Network Stack) and as we see the result of esBPF, Kernel doesn't need any extra tasks.\nThe project could be better than packet filtering in Network Stack in some cases even though the worst case takes CPU resources about four times than the best case. Of course, It depends on how big/long cBPF instructions are in esBPF though.\nThe project is still in progress such as being more flexible, optimizing, and taking Cache mechanism.\nI figured out through this Stress-testing that it will be worth putting more effort into the project and keep working, at least I don't waste my time. Also, it was a nice time to take the responsibility for the entire process from design to testing.\nI hope everyone has enjoyed the article, cheers ;-)\n","link":"https://www.ooseel.net/me/2022/11/esbpf-stress-testing-compares-software-offload-with-iptables/","section":"posts","tags":["Ubuntu","Arm64","Linux","Kernel"],"title":"esBPF: Stress-Testing compares Software-Offload with iptables"},{"body":"","link":"https://www.ooseel.net/me/tags/kernel/","section":"tags","tags":null,"title":"kernel"},{"body":"","link":"https://www.ooseel.net/me/tags/linux/","section":"tags","tags":null,"title":"Linux"},{"body":"","link":"https://www.ooseel.net/me/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://www.ooseel.net/me/tags/ubuntu/","section":"tags","tags":null,"title":"ubuntu"},{"body":"Whole processes, git cloning the right codebase from a repository, installing all the packages, kernel configuration, and finally go building are such a challenge for beginners like me. Fortunately, Ubuntu Kernel Team provides an easy system for building kernel though.\nIn this article, we are going to look at some requirements. In more detail, try installing build tools, get ready, and building :-)\nGet ready for upstream kernel and environment Canonical, a company mainly supports Ubuntu distro maintains its Kernel sources at Launchpad, but for Raspberry Pi, it's maintained at this repository.\nI'm currently running Kinetic release on my raspberry pi but wanna switch to an upstream kernel of master-next branch. Launchpad page has an instruction such as what to do in each branch of each repository in more detail but all I need now is the following address to clone,\n1$ mkdir linux; cd linux 2$ git clone -b master-next \\ 3 https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux-raspi/+git/kinetic \\ 4 ./ubuntu-upstream-kernel 5$ cd ubuntu-upstream-kernel also, we have to install the following packages but keep in mind that some of them aren't supported in older releases or needs. This article is based on 22.04.1 LTS.\n1$ sudo apt build-dep linux linux-image-$(uname -r) 2$ sudo apt install libncurses-dev gawk flex bison openssl libssl-dev dkms \\ 3 libelf-dev libudev-dev libpci-dev libiberty-dev autoconf llvm curl \\ 4 gcc-12-aarch64-linux-gnu gcc-12-aarch64-linux-gnu-base gcc-12 g++-12 \\ 5 linux-tools-common fakeroot debhelper gcc-aarch64-linux-gnu Let's go! Most of the branches for Ubuntu kernel have extra directories, debian, debian.master, and debian.raspi which have special files such as basic scripts, configs, and target info respectively. In my case, raspberry pi configs are in the latter one.\nAll we need to do is run scripts in debian but others are nothing care.\n1# Now we are in \u0026#39;ubuntu-upstream-kernel\u0026#39; 2 3$ export $(dpkg-architecture -aarm64) 4$ export CROSS_COMPILE=aarch64-linux-gnu- 5 6$ LANG=C fakeroot debian/rules clean # cleaning any garbages 7$ LANG=C fakeroot debian/rules editconfigs # menuconfig if you need 8$ LANG=C fakeroot debian/rules binary-headers binary binary-perarch It will take a long and long time even though you are done with having meals, and going for a walk... so forget it at least for 2 hours.\nThen you have some deb packages in the parents' directory like these,\n1linux-buildinfo-5.19.0-1006-raspi_5.19.0-1006.13_arm64.deb 2linux-modules-extra-5.19.0-1006-raspi_5.19.0-1006.13_arm64.deb 3linux-headers-5.19.0-1006-raspi_5.19.0-1006.13_arm64.deb 4linux-raspi-headers-5.19.0-1006_5.19.0-1006.13_arm64.deb 5linux-image-5.19.0-1006-raspi_5.19.0-1006.13_arm64.deb 6linux-modules-5.19.0-1006-raspi_5.19.0-1006.13_arm64.deb It's all up to you what to do with them, cheers :-)\n","link":"https://www.ooseel.net/me/2022/11/build-upstream-ubuntu-kernel-for-arm64-raspberry-pi/","section":"posts","tags":["ubuntu","arm64","kernel"],"title":"Build upstream Ubuntu Kernel for Arm64 Raspberry-Pi"},{"body":"해외 여행 준비로 English Speaking과 관련된 여러가지 방법을 찾아보고 있다. 한달 뒤에 출국 예정이므로 기본 대화가 가능하고 틀려도 자신감있게 말하기 위해 다음과 같은 방법을 생각해봤는데...\n 오프라인 언어 교환에 나간다. 전화 영어를 해본다. 미드 쉐도잉 온라인 언어 교환 앱 사용하기.  1. 오프라인 언어 교환 참석 나와 맞지 않는다. 예전에 자신감없고 speaking이 익숙하지 않은 상태에서 나가니까 2시간 내내 아무말도 안하고 free talking인데 할 얘기가 없어서 Ok, Yes, No 만 하다가 왔다. 그래서 패스.\n2. 전화 영어 1:1이고 튜터가 교정을 해주는 장점이 있는데 내가 초보자 수준이라서 오늘 하루 어땠니, 뭐했니, 감정 표현 같은 것들이 대부분이고 유료이다. 효율이 안 나와서 패스.\n3. 미드 쉐도잉 단기간에 목표(기본적인 대화 및 자신감 상승) 달성이 힘들것 같아 패스. 내가 좋아하는 미드도 없다.\n3. 온라인 언어 교환 앱 사용 - hilokal 3일전에 hilokal 이란 언어 교환 앱을 알게되었다. 클럽하우스처럼 참여해서 직접 target language로 speaking하고 language improvement가 목적이다. 여기에 크게 2가지 성격을 가진 테이블(여기선 방을 테이블이라 칭하더라)이 존재한다. 첫번째는 그냥 모여서 랜덤 채팅식으로 얘기하는데 말 엄청빠르고 slang이 너무 많다. 영어에 익숙해지면 small talk 연습으로 좋은것 같다. 두번째는 테이블 호스트가 특정 토픽을 가져오고 사람들이 참여하여 턴제 방식으로 돌아가며 질문하거나 간단한 내용을 읽고 대답하기다.\n나는 두번째 방법이 맞는것 같아 해당 테이블들에 참여해서 얘기하는데 너무 재밌다 ㅋㅋㅋ 이게 전혀 공부같지 않고 게임하는 느낌이다. 거기다 모르는 단어 나오면 물어보고 호스트가 대답해주는데 영어로 소통하니 단어장만 보며 외우는것보다 효율이 너무 좋다. 그냥 바로 암기된다.\n오늘은 호스트가 Stephen Hawking 전기에 대해 짧은 예문을 가져왔다. 그래서 한 페이지별로 3명이 돌아가며 읽고 모르는 단어에 대해 뜻과 발음을 피드백해주었다. 문제도 내고 답을 아는 사람이 대답을 하고 다음 예문으로 넘어갔다. 덕분에 paralyze, vigorous란 단어를 알게되었다.\n또한 앱을 사용하며 알게된 나쁜 버릇은 나는 무조건 빠르게 얘기하려고 한다는 것이다. 말을 빠르게 하려니 문장 구성이 부실해지고 요점도 안드로메다로 날아간다. 그래서 천천히 말하며 요점을 간단하게 설명하기 위해 의식적으로 노력중이다.\n공격적으로 참여하고 질문하고 얘기하니 자신감이 점점 생겨가고 영어로 말하는것에 익숙해지는 것 같다. 이 앱으로 효율적이게 공부하려면 틀리기를 두려워말고 무조건 공격적으로 말하고 즐기며 놀이처럼 해야한다!\n(앱 광고비 받지 않았다. 그냥 써보니 재밌더라)\n","link":"https://www.ooseel.net/me/2022/03/training-english-speaking-at-home/","section":"posts","tags":null,"title":"집에서 English Speaking 연습하기"},{"body":"","link":"https://www.ooseel.net/me/tags/monthly-insight/","section":"tags","tags":null,"title":"monthly-insight"},{"body":"General  삶에 대한 질문? 그 답을 찾다: 광고기획자 박웅현  Youtube에 올라온 EBS 영상 클립이고 총 #1, #2로 구성되어 있다. 청중들로부터 여러가지 질문을 받아 QNA 하는 형식으로 되어 있는데 깊은 생각을 하게끔 만드는 답변을 많이 주신다. 내가 존경하는 분이며 삶에 대해 자신'만'의 답을 찾길 원하신다면 추천한다.    ","link":"https://www.ooseel.net/me/2021/07/hashtag-monthly-insight-2021-07/","section":"posts","tags":["monthly-insight"],"title":"월간 인사이트 - 2021년 7월호"},{"body":"잘못된 정보는 https://github.com/memnoth/me/issues/1에 남겨주시기 바랍니다.\nList  Startup에서 D-cache=off 임에도 불구하고 cache line invalidation 하는 목적이 뭔가요?  QnA Q. 아래 코드에서 D-cache = off 임에도 불구하고 cache line invalidation 하는 목적이 뭔가요? 1// \u0026#39;head.S\u0026#39; of linux kernel 5.10 2/* 3* Kernel startup entry point. 4* --------------------------- 5* 6* The requirements are: 7* MMU = off, D-cache = off, I-cache = on or off, 8* x0 = physical address to the FDT blob. 9* 10* 기타 내용들... 11*/ 12 13.... 14 15// In \u0026#39;preserve_boot_args\u0026#39; label, try invalidating cache lines 16// addressed to \u0026#39;boot_args\u0026#39; space. 17mov x1, #0x20 // 4 x 8 bytes 18b __inval_dcache_area // tail call A. 'D-cache = on' 이후 data corruption을 방지하기 위함입니다. 커널이 초기화 작업을 진행하기 이전에는 일반적으로 bootloader가 커널이 부팅하는데 필요한 최소한의 장치들을 초기화합니다. 여기에는 메모리와 관련된 작업들도 당연히 포함되고요. 커널의 startup point에서는 이전에 부트로더가 어떤 작업을 했는지 모릅니다만 위 requirements와 최소한의 장치만 초기화되면 됩니다. 이때 cache에는 어떤 정보들이 들어 있는지 모르는 상태이고요. 따라서 dirty data가 캐싱되어 있을 가능성이 높습니다.\nbootloader가 사용한 또는 커널이 앞으로 사용할 주소에 대해 cache line invalidation 없이 D-cache=on 시점에서 load/store 명령어를 수행하면 아래와 같은 시나리오가 발생할 수 있습니다. Startup point에서 D-cache=off 인 이유는 이것과 관련성이 적지만 on일 때를 생각해보면 invalidation은 충분한 이유입니다.\n Load insts\nLoad의 src 주소가 cache line에 존재한다면 hit 되어 dirty data가 fetch될 가능성이 높습니다. Store insts\nStore의 dest 주소가 cache line에 존재한다면 hit 되어 해당 라인의 데이터가 계속적으로 변경됩니다. 이때 데이터는 실제 예측한 데이터가 아니겠죠. dc clean을 수행하거나 line이 eviction 되는 시점에서 메인 메모리의 데이터는 out-of-date 이므로 line에 있는 dirty data로 업데이트됩니다.  따라서 다음과 같은 결론에 도달하게 됩니다. Chip booting 후 또는 bootloader가 사용하고 난 후 cache line에 남아 있는 dirty data를 정리하고 D-cache=on 시점에서 new data를 메인 메모리로부터 참조하기 위함입니다.\nReferences  https://stackoverflow.com/a/67347295 Enabling and disabling the DCache  ","link":"https://www.ooseel.net/me/2021/07/hashtag-cache-memory-qna/","section":"posts","tags":["linux","kernel","arm64"],"title":"Cache Memory QnA"},{"body":"Q. 아래와 같이 startup point에서 MMU 와 D-Cache의 상태가 off 여야 하는데 이유가 뭔가요? 1 // \u0026#39;head.S\u0026#39; of linux kernel 5.10 2 /* 3* Kernel startup entry point. 4* --------------------------- 5* 6* The requirements are: 7* MMU = off, D-cache = off, I-cache = on or off, 8* x0 = physical address to the FDT blob. 9* 10* This code is mostly position independent so you call this at 11* __pa(PAGE_OFFSET). 12* 13* Note that the callee-saved registers are used for storing variables 14* that are useful before the MMU is enabled. The allocations are described 15* in the entry routines. 16*/ A-1. MMU MMU는 CPU가 명령어를 수행할 때 메모리에 접근할 vaddr(Virtual Address)를 paddr(Physical Address)로 변환하는 작업을 수행합니다. 그리고 이때 사용되는 자료구조가 주소 매핑 테이블인데 이는 커널이 생성합니다. Startup 코드가 수행되는 시점에서는 매핑 테이블이 존재하지 않는데 MMU가 on 되어 있다면 메모리 주소가 vaddr로 해석됩니다. 결국 MMU가 수행되고 이는 paddr로 변환되어 의도치 않은 동작이 수행됩니다. 이와 같은 이유로 매핑 테이블이 생성되기 이전에는 MMU를 off 해야합니다.\nA-2. D-Cache D-Cache는 CPU와 메인 메모리 사이에서 데이터를 빠르게 접근하기 위한 저장소 역할을 수행합니다. 대부분의 시스템 프로그래머들은 알다시피 종종 캐시와 메모리간 데이터 싱크(Sync) 문제들을 마주하게 되는데 startup 시점에서는 paddr에서 데이터를 직접 읽거나 써야 합니다. 그러나 D-Cache가 on 되어 있다면 paddr에서 데이터를 읽는 대신 캐시 메모리에서 읽으므로 의도치 않은 동작을 수행하게 됩니다. 이와 같은 이유로 D-Cache도 off 해야합니다.\n","link":"https://www.ooseel.net/me/2021/07/why-mmu-and-d-cache-must-be-off-at-startup-point-in-arm64/","section":"posts","tags":["linux","kernel","arm64"],"title":"Why MMU and D-Cache must be off at Startup point"},{"body":"General  '월간 인사이트' 시작  안도형님이 작성하신 This month I Learnd을 보고 시작했다. 포스트하는건 귀찮지만 인사이트를 얻은 글에 대해 월 단위로 정리하여 공유하기에 좋은 방법이라 생각한다. 기억속에 고이 잠든 인사이트 넘치는 글들이 너무나 많다!   평범한 일상이 소중한 이유  퇴근 후 맥주 한 잔, 저녁 노을을 보며 뛸 수 있는 여유. 30대에 들어서며 20대에 가졌던 생각이 많이 바뀌었다. 20대에는 지금의 나는 내 인생에서 두번 다시 오지 않아!라며 악착같이 열심히 경험쌓으며 살았다. 30대가 되고 나서는 인생의 큰 이벤트보다 일상의 소소한 행복을 더 원한다. 성공보다 소중한 사람들과의 추억이 더 중요해지는 시기일까? 변하지 않을 것 같았던 내가 서서히 변해가는가보다.   사수없이 일하며 성장하는 법  개발 2년차, 내겐 사수가 있었을까? 사수란 어떤 존재일까? 사수가 있으면 좋지만, 우리는 하루 빨리 사수로부터 독립하여 스스로 나아가야 한다. 이 글은 그렇게 성장하는 방법에 대해 힌트를 준다.    Books  소프트웨어 장인 - 읽는 중  올해 상반기 최고의 책을 꼽으라면 당연 이 책이라 말할 수 있다. 첫 입사 이후 이건 아닌데..., 이 업무 프로세스가 올바른 것일까..라며 수 없이 생각하고 스스로에게 질문해왔던 날들 그러나 소리없는 아우성. 그 모든 질문에 대한 명쾌한 답(?)이 이 책 하나에 대부분 들어있다. 개발자로서 첫 업무를 시작하는, 그러나 멀고 먼 험난한 길을 걸으려는 사람들에게 이 책은 올바른 길로 인도하는 나침반과 같은 존재이다.    ","link":"https://www.ooseel.net/me/2021/06/hashtag-montly-insight-2021-06/","section":"posts","tags":["monthly-insight"],"title":"월간 인사이트 - 2021년 6월호"},{"body":"As some of you already know SIOCGIFADDR isn't supported on IPv6 socket although SIOCSIFADDR is. For sure there is a reason linux kernel doesn't do so but it's worth to build up by our hands, then we get to know much more in detail. This is good for us as a studying purpose rather than use in product.\nWe define simple ideas with some requirements, then look at kernel patch and a demo.\nIdeas A significant one is that an interface could have multiple IPv6 addresses, so our prototype would be the following result in user program perspective ...\n Take an IPv6 address and an interface name via args to set Get and print an IPv6 address mapped to an index of the required interface via its args. Assume the index would be 0 if the args isn't passed.  Assigning an address isn't a big deal but trying to get one is a bit complicated. Because we have to pass an index to kernel. For the requirement, use a member, struct in6_addr of struct in6_ifreq which the size of memory is 128 bits. Split the space into two parts and put the index value into the second space. We could even split it into 4 spaces of 32 bits based though, make it simple.\n1.-------------------------------------------. 2| 128 bits | \u0026lt;-- struct in6_addr 3\u0026#39;-------------------------------------------\u0026#39; 4 5^--------------------^ ^--------------------^ 6 64 bits 64 bits We use the following struct on both kernel and user program to serialize between them. It's originally from kernel, but manually port to the user program. Remember ifr6_addr is very important.\n1struct in6_ifreq { 2 struct in6_addr ifr6_addr; 3 u_int32_t ifr6_prefixlen; 4 unsigned int ifr6_ifindex; 5}; Here is a part of our test code, cmd_get function is the main routine implemented with SIOCGIFADDR but you could see the full code here.\n1static int cmd_get(int fd, int argc, char *argv[]) 2{ 3 char buf[256] = { 0, }; 4 struct in6_ifreq req; 5 struct ifreq ifr; 6 uint64_t *index = \u0026amp;((uint64_t*)\u0026amp;req.ifr6_addr)[1]; 7 8 init_ifindex(ifr); 9 10 memset(\u0026amp;req, 0, sizeof(struct in6_ifreq)); 11 /* Set index of nth address on the interface */ 12 *index = (argc == 1) ? 0 : atoi(argv[1]); 13 req.ifr6_prefixlen = 64; 14 req.ifr6_ifindex = ifr.ifr_ifindex; 15 retval_if( ioctl(fd, SIOCGIFADDR, \u0026amp;req), -5 /* 251 */, NULL ); 16 17 inet_ntop(AF_INET6, \u0026amp;req.ifr6_addr, buf, sizeof(buf)); 18 printf(\u0026#34;interface (%s) addr (%s)\\n\u0026#34;, argv[0], buf); 19 20 return 0; 21} 22 23int main(int argc, char *argv[]) 24{ 25 /* Skip useless code */ 26 retval_if( ((fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP)), fd \u0026lt; 0), 27 -2 /* 254 */, NULL ); 28 /* Skip useless code */ 29 ret = cmd_get(fd, argc-2, argv+2); 30} As our ideas, a pointer named index points to the second space of struct in6_addr which sets on demand and assume our requirement is always with 64 bits prefix length.\nKernel patch Code is a bit simple. Look up and compare the index on the specified interface. See the line 44, kernel knows what number of addresses a user asks by parsing the index from user buffer and compare on 48 line. If the number is existed, copy the address to the same buffer and return back on the line, 84.\n1diff --git a/include/net/addrconf.h b/include/net/addrconf.h 2index ab8b3eb53d..97f8de4c09 100644 3--- a/include/net/addrconf.h 4+++ b/include/net/addrconf.h 5@@ -77,6 +77,7 @@ int addrconf_init(void); 6 void addrconf_cleanup(void); 7 8 int addrconf_add_ifaddr(struct net *net, void __user *arg); 9+int addrconf_get_ifaddr(struct net *net, void __user *arg); 10 int addrconf_del_ifaddr(struct net *net, void __user *arg); 11 int addrconf_set_dstaddr(struct net *net, void __user *arg); 12 13diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c 14index 635b2482fa..46e9a80e7a 100644 15--- a/net/ipv6/addrconf.c 16+++ b/net/ipv6/addrconf.c 17@@ -2985,6 +2985,46 @@ static int inet6_addr_add(struct net *net, int ifindex, 18 return PTR_ERR(ifp); 19 } 20 21+static int inet6_addr_get(struct net *net, 22+ int ifindex, 23+ u32 ifa_flags, 24+ const struct in6_addr *pfx, 25+ unsigned int plen) 26+{ 27+\tstruct inet6_ifaddr *ifp; 28+\tstruct inet6_dev *idev; 29+\tstruct net_device *dev; 30+\tu64 upper, lower, i = 0; 31+ 32+\tif (plen \u0026gt; 128) 33+\treturn -EINVAL; 34+ 35+\tdev = __dev_get_by_index(net, ifindex); 36+\tif (!dev) 37+\treturn -ENODEV; 38+ 39+\tidev = __in6_dev_get(dev); 40+\tif (!idev) 41+\treturn -ENXIO; 42+ 43+\tupper = ((u64*)pfx)[0]; 44+\tlower = ((u64*)pfx)[1]; 45+ 46+\tread_lock_bh(\u0026amp;idev-\u0026gt;lock); 47+\tlist_for_each_entry(ifp, \u0026amp;idev-\u0026gt;addr_list, if_list) { 48+\tif (ifp-\u0026gt;prefix_len == plen \u0026amp;\u0026amp; lower == i++) { 49+\tread_unlock_bh(\u0026amp;idev-\u0026gt;lock); 50+ 51+\tmemcpy(pfx, \u0026amp;(ifp-\u0026gt;addr), sizeof(struct in6_addr)); 52+\treturn 0; 53+\t} 54+\tif (i \u0026gt; lower) 55+\tbreak; 56+\t} 57+\tread_unlock_bh(\u0026amp;idev-\u0026gt;lock); 58+\treturn -EINVAL; 59+} 60+ 61 static int inet6_addr_del(struct net *net, int ifindex, u32 ifa_flags, 62 const struct in6_addr *pfx, unsigned int plen) 63 { 64@@ -3053,6 +3093,28 @@ int addrconf_add_ifaddr(struct net *net, void __user *arg) 65 return err; 66 } 67 68+int addrconf_get_ifaddr(struct net *net, void __user *arg) 69+{ 70+\tstruct in6_ifreq ireq; 71+\tint err; 72+ 73+\tif (!ns_capable(net-\u0026gt;user_ns, CAP_NET_ADMIN)) 74+\treturn -EPERM; 75+ 76+\tif (copy_from_user(\u0026amp;ireq, arg, sizeof(struct in6_ifreq))) 77+\treturn -EFAULT; 78+ 79+\trtnl_lock(); 80+\terr = inet6_addr_get(net, ireq.ifr6_ifindex, 0, \u0026amp;ireq.ifr6_addr, 81+\tireq.ifr6_prefixlen); 82+\trtnl_unlock(); 83+ 84+\tif (!err \u0026amp;\u0026amp; copy_to_user(arg, \u0026amp;ireq, sizeof(struct in6_ifreq))) 85+\terr = -EFAULT; 86+ 87+\treturn err; 88+} 89+ 90 int addrconf_del_ifaddr(struct net *net, void __user *arg) 91 { 92 struct in6_ifreq ireq; 93diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c 94index 14ac1d9112..6bb0da9fd5 100644 95--- a/net/ipv6/af_inet6.c 96+++ b/net/ipv6/af_inet6.c 97@@ -550,6 +550,8 @@ int inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg) 98 99 case SIOCSIFADDR: 100 return addrconf_add_ifaddr(net, (void __user *) arg); 101+\tcase SIOCGIFADDR: 102+\treturn addrconf_get_ifaddr(net, (void __user *) arg); 103 case SIOCDIFADDR: 104 return addrconf_del_ifaddr(net, (void __user *) arg); 105 case SIOCSIFDSTADDR: Demo time! Now make a test interface named br-demo on bridge layer, then assign an IPv6 address to it. Of course, try to get each addresses assigned to the interface.\n1root@OpenWrt:/# brctl addbr br-demo \u0026amp;\u0026amp; ifconfig br-demo up 2root@OpenWrt:/# ifconfig 3br-demo Link encap:Ethernet HWaddr 06:FA:DC:0E:5F:84 4 inet6 addr: fe80::4fa:dcff:fe0e:5f84/64 Scope:Link 5 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 6 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 7 TX packets:5 errors:0 dropped:0 overruns:0 carrier:0 8 collisions:0 txqueuelen:1000 9 RX bytes:0 (0.0 B) TX bytes:454 (454.0 B) 10 11root@OpenWrt:/# demo_ipv6 12usage: demo_ipv6 \u0026lt;command\u0026gt; 13 14- command 15 add : \u0026lt;ifname\u0026gt; \u0026lt;ipv6 address\u0026gt; 16 get : \u0026lt;ifname\u0026gt; [index] 17 18root@OpenWrt:/# demo_ipv6 add br-demo 2001:0db8:85a3::8a82 19root@OpenWrt:/# ifconfig br-demo 20br-demo Link encap:Ethernet HWaddr 06:FA:DC:0E:5F:84 21 inet6 addr: fe80::6ce4:38ff:fe99:74d2/64 Scope:Link 22 inet6 addr: 2001:db8:85a3::8a82/64 Scope:Global 23 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 24 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 25 TX packets:12 errors:0 dropped:0 overruns:0 carrier:0 26 collisions:0 txqueuelen:1000 27 RX bytes:0 (0.0 B) TX bytes:1360 (1.3 KiB) 28 29root@OpenWrt:/# demo_ipv6 get br-demo 30interface (br-demo) addr (2001:db8:85a3::8a82) 31root@OpenWrt:/# demo_ipv6 get br-demo 1 32interface (br-demo) addr (fe80::6ce4:38ff:fe99:74d2) 33root@OpenWrt:/# demo_ipv6 get br-demo 2 34root@OpenWrt:/# echo $? 35251 36root@OpenWrt:/# demo_ipv6 get br-demo 0 37interface (br-demo) addr (2001:db8:85a3::8a82) Conclusion This were a simple tutorial though, we could see that IOCTL programming is a way to communicate between kernel and user programs and give lots of opportunities for hacking the kernel.\nStay Safe!\n","link":"https://www.ooseel.net/me/2021/02/design-siocgifaddr-on-ipv6-socket/","section":"posts","tags":null,"title":"Design SIOCGIFADDR on IPv6 socket"},{"body":"1년을 되돌아 보는 행동은 언제나 낯설고 긴장된다. 자기 반성을 위해 지난 1년간의 활동을 객관적으로 바라봐야 하는데 이 곳에 말은 못해도 가슴 쓰린 기억들을 끄집어 내야하니 말이다. 이 글은 **나**를 되돌아 보는 글이다.\n9월부터 실내암벽 등반을 다시 시작했다. 지금은 2.5단계로 인해 쉬고 있지만 1월에 그만둔 뒤로 8개월만이었다. 회사-집-공부 패턴으로 몇 달을 지내니 스트레스가 풀리지 않아 불면증에 슬럼프까지 겹쳤는데 자존감 측면에서 확실히 운동하고 안 하고의 차이가 존재한다. 땀을 확 빼고 집에 갈 때 느끼는 밤 공기의 상쾌함, 이 느낌은 여전히 내가 살아 존재하는 느낌을 준다. 또한 사소한 문제라도 몇 개 풀었다는 사실과 암장 회원들과의 유대관계가 회사 업무로 인해 강직된 마음을 녹여준다. 모든 인연에서 배울 점이 있음을 요즘들어 많이 느끼는데 다들 착하고 자유롭고 유연한 사고를 가지고 있다. 그렇기에 그들과 함께하는 것이 즐거운지도 모르겠다.\n하반기에는 자기객관화를 위해 노력을 많이 했으나 여전히 혼란스럽다. 나에 대해 몇가지 알게된 사실은 꼰대화가 진행되고 있다는 것과 시간낭비가 많다는 것이다. 나와 다름을 인정하지 못할 때가 종종 있고 위로라는 명목하에 주는 강제 조언, 행동은 어른스럽지 못했고 남탓할 때도 있었다. 이러다 보니 정작 중요한 것에 집중하지 못함은 물론 나의 행동이 상대방에게 상처가 되었고 소모되는 에너지도 많았다. 내년은 부디 덜 꼰대스러웠으면 하는 바램이다.\n개발자로서 도전과 깨달음 운이 좋았다. 올해는 컨트리뷰톤을 통해 한 달간 새로운걸 경험할 수 있는 좋은 기회가 있었으니 말이다. 인메모리 캐시 서버 솔루션(ARCUS)팀에 참여하였는데 평소에도 이런 종류의 솔루션들이 데이터를 처리하는 방법에 대해 궁금하기도 했다. 해시맵이나 선형 리스트에 대한 알고리즘들 말이다. 캐싱 솔루션들은 퍼포먼스가 좋아야하니 효율적인 알고리즘을 사용하고 있어 학부에서 얕게 배운 내용들이 현장에서 사용되는 방식을 습득하기에 가장 좋은 환경이다.\n이번엔 참여하는 방식을 조금 달리 해봤는데 멘토님들이 주시는 과제에 대해 수동적으로 행동하기 보다 토이 프로젝트를 주도했다. FUSE 프레임워크와 ARCUS 솔루션을 조합하여 캐시 서버 메모리에 저장된 Key-Value 데이터들을 VFS(가상 파일 시스템)으로도 제공하는 프로젝트였다. 이에 대해 간략히 설명하자면 엔진에 키가 저장될 때 VFS의 캐시 리스트에도 동일한 키를 저장한다. 이 작업은 엔진과 VFS의 Key 리스트 동기화가 중요하다. 이후에 사용자가 VFS이 제공하는 파일(이름이 Key와 동일)에 대해 cat, tree 명령어를 수행하면 엔진을 통해 Value 값을 가져와 사용자에게 제공한다. 자세한 내용은 프로젝트 링크 참고.\n회사에서 새 프로젝트를 진행하던 시기와 컨트리뷰톤이 겹쳤는데 프로젝트도 기간이 짧았고 컨트리뷰톤은 한 달 남짓이었다. 둘다 일정이 타이트해서 업무 외 남는 시간에는 평일/주말 상관없이 밤 늦게까지 엔진을 분석하고 VFS 레이어를 구현했다. 이때 너무 힘들었고 스트레스도 많이 받았지만 임계점을 한번 넘기니 이후로 중규모 프로젝트를 분석하는데 자신감이 생기기 시작했다.\n컨트리뷰톤 이후로 JavaScript 엔진인 JerryScript 스터디를 시작했는데 진행 경험이 거의 없었고 예전에도 한번 시도했다가 실패한 적이 있었다. 우연찮게 백기선님이 올리신 스터디 모집에 대한 영상을 보게 되었는데 \u0026quot;처음에는 누구나 서툴다. 그러나 시도하면서 피드백을 받고 보완해 가는 것이다\u0026quot;라고 말씀하신 것에 용기를 얻어 시작했다. 중간에 그만두더라도 시도 한 것이 하지 않은 것보다 낫지 않겠는가. 스터디에 참여하신 분의 실력이 좋으셔서 진도가 정말 빨리 나갔는데, 총 8주를 계획했으나 첫 주에 이미 Lexer 파트에 대해 큰 그림을 그렸고 마지막 주에는 패치를 반영시켰다. 2기를 진행하려다가 커널과 관련된 부분을 공부하는게 좋을 것 같아서 그만두었지만 그동안의 스터디가 시간낭비라는 생각은 들지 않는다.\n데이터베이스 엔진, 컴파일러 모두 내가 관심있던 분야였지만 이 글을 쓰는 시점에 깨달은 것은 두 분야에 대해 아직은 그냥 흥미만 있다는 것이다. 어쩌면 너무 이른 판단일지도 모르겠다. 하지만 한 가지 사실은 지금은 리눅스 커널이 더 재밌고 이것에 열정을 쏟고 싶다. JerryScript는 당분간 내 흥미의 한 공간에 고이 모셔두고 재미로 분석하려고 한다.\n회사에서는 이것저것 다양하게 경험했다. 흥미로운 이슈들을 많이 주셨고 메인 업무이기도 했는데 커널 관련된게 몇 가지 있었다. 1년차 개발자가 무엇을 알겠는가, 커널 버그 대부분이 디버깅하기 무척 어려웠는데 시간은 계속 흐르고 일정은 다가오는데 진행이 안되니 스트레스를 많이 받았다. 이때 자존감이 완전 바닥을 쳤고 \u0026quot;이 길이 내 길이 아닌가\u0026quot; 라는 생각이 들며 굉장히 심란했다. 불평해봤자 상황은 나아지지 않으니 어떻게든 해결하려고 밤새 공부하며 발버둥쳤고 다행히도 일정내에 해결했다.\n스트레스 받던 당시에는 몰랐지만 돌아보니 저 경험이 성장의 기폭제로 작용한 것 같다. 이후로 리눅스 커널을 바라보는 시각과 업무에 대한 태도가 달라졌으며 버그에 대한 두려움은 여전히 존재하지만 마음은 한층 더 단단해졌다.\n마치며.. 올해는 바쁘게 지냈음에도 불구하고 아쉬움이 많이 남는다. 그 아쉬움은 \u0026quot;그때 적극적으로 행동했더라면..\u0026quot; 하는 마음이리라. 내년에는 꼭 \u0026quot;2021년은 덜 꼰대스러웠네요. 다행입니다!\u0026quot; 라는 말을 할 수 있길 바라고 이 글을 읽는 분들에게는 축복이 따르길 기원한다.\n(배고프니 치킨 🍗 시켜야겠다)\n","link":"https://www.ooseel.net/me/2020/12/look-back-to-2020/","section":"posts","tags":null,"title":"2020년을 되돌아 보는 글"},{"body":"Have you ever experienced such horrible signals between core processes which might crash a whole system? I had done. Unknown signals are a kind of critical issue in product.\nSomeone says \u0026quot;Better safe than sorry\u0026quot;. I like that quote. Even though software world is totally chaotic on bugs, we should at least try some approaches being safe. Especially signals. They never log while on their way unless we trigger so that could quietly stab your back one day if you are off the guard.\nThis article is about an approach let you be safe from them.\nOur softwares are running on a software. we call it as Operating System. If we can read its code, modify as we want, why not put our idea into it? Say more straight, \u0026quot;hook the code where signals walk inside kernel\u0026quot;.\nPractice! time Let's specify some wishes for our goal. I'm going to make this more simple and they are only three which are signals' ...\n Sender's name/pid Signal's number Receiver's name/pid  Signal processing has three stages in simple saying.\n kill syscall or from kernel ready to signal wake up the target process  We're going to hook at the last of the second stage. Because most exceptions, for example dereferencing NULL pointers are already considered at the boundary between the second and third.\n1/* kernel/signal.c */ 2static int __send_signal(int sig, 3 struct kernel_siginfo *info, 4 struct task_struct *t, 5 enum pid_type type, 6 bool force) 7{ 8 struct sigpending *pending; 9 struct sigqueue *q; 10 int override_rlimit; 11 int ret = 0, result; 12 13 /* ... A LOT CODE HERE ... */ 14 15 complete_signal(sig, t, type); 16ret: 17 trace_signal_generate(sig, info, t, type != PIDTYPE_PID, result); 18 return ret; 19} Here's one of functions signals walk and as the callee's name, complete_signal gives a clue, hook points are its ahead/behind. I pick ahead.\nNow code a few lines.\n1/* kernel/signal.c */ 2static int __send_signal(int sig, 3 struct kernel_siginfo *info, 4 struct task_struct *t, 5 enum pid_type type, 6 bool force) 7{ 8 struct sigpending *pending; 9 struct sigqueue *q; 10 int override_rlimit; 11 int ret = 0, result; 12 13 /* ... A LOT CODE HERE ... */ 14 15 /* Our code! */ 16 if (sig != 17 /* SIGCHLD in Arm */ \u0026amp;\u0026amp; 17 sig != 14 /* SIGALRM in Arm */ \u0026amp;\u0026amp; 18 info \u0026amp;\u0026amp; t) 19 { 20 int srcpid, dstpid; 21 char src[TASK_COMM_LEN] = { 0, }; 22 char dst[TASK_COMM_LEN] = { 0, }; 23 struct task_struct * cur_task = NULL; 24 25 if (!force) { 26 srcpid = info-\u0026gt;si_pid; 27 cur_task = find_task_by_vpid(srcpid); 28 } else 29 srcpid = 0; /* just for kernel case */ 30 31 dstpid = t-\u0026gt;pid; 32 memcpy(src, cur_task ? cur_task-\u0026gt;comm : \u0026#34;kernel\u0026#34;, TASK_COMM_LEN-1); 33 memcpy(dst, t-\u0026gt;comm, TASK_COMM_LEN-1); 34 35 printk(KERN_INFO \u0026#34;Signal :: (%s %d) --[%d]--\u0026gt; (%s %d)\\n\u0026#34;, 36 src, srcpid, 37 sig, 38 dst, dstpid); 39 } 40 41 complete_signal(sig, t, type); 42ret: 43 trace_signal_generate(sig, info, t, type != PIDTYPE_PID, result); 44 return ret; 45} There are two type of sender, SI_USER and SI_KERNEL. force is set to false or true respectively. According to that, cur_task has sender's info or being NULL represents kernel so that we finally decide sender's name.\nWe do ignore SIGCHLD and SIGALRM used for a signal notification to its parent that itself exited and time interval like a timer by kernel respectively to prevent dmesg flooding.\ndmesg 1root@OpenWrt:/# reboot 2[ 56.365579] Signal :: (reboot 1286) --[15]--\u0026gt; (procd 1) 3[ 56.452796] Signal :: (procd 1) --[15]--\u0026gt; (hostapd 705) 4[ 56.460590] Signal :: (procd 1) --[15]--\u0026gt; (wpa_supplicant 706) 5[ 56.504500] Signal :: (killall 1350) --[15]--\u0026gt; (dropbear 597) 6[ 56.551519] Signal :: (procd 1) --[15]--\u0026gt; (odhcpd 822) 7[ 56.599167] Signal :: (procd 1) --[15]--\u0026gt; (logd 430) 8[ 56.701690] Signal :: (netifd 766) --[15]--\u0026gt; (udhcpc 1044) 9[ 56.728474] br-wan: port 1(eth0) entered disabled state 10[ 56.738012] device eth0 left promiscuous mode 11[ 56.743576] br-wan: port 1(eth0) entered disabled state 12[ 56.769219] smsc95xx 1-1.1:1.0 eth0: hardware isn\u0026#39;t capable of remote wakeup 13[ 57.730085] Signal :: (procd 1) --[15]--\u0026gt; (ubusd 141) 14[ 57.737611] Signal :: (procd 1) --[15]--\u0026gt; (askfirst 143) 15[ 57.745295] Signal :: (procd 1) --[15]--\u0026gt; (urngd 177) 16[ 57.752705] Signal :: (procd 1) --[15]--\u0026gt; (brcmf_wdog/mmc1 293) 17[ 57.760934] Signal :: (procd 1) --[15]--\u0026gt; (dnsmasq 534) 18[ 57.768427] Signal :: (procd 1) --[15]--\u0026gt; (netifd 766) 19[ 57.775770] Signal :: (procd 1) --[15]--\u0026gt; (ntpd 1070) 20[ 57.782966] Signal :: (procd 1) --[15]--\u0026gt; (sh 1476) 21[ 57.790105] Signal :: (ntpd 1070) --[15]--\u0026gt; (ntpd 1070) 22[ 57.790712] Signal :: (kernel 0) --[1]--\u0026gt; (askfirst 143) 23[ 58.791265] Signal :: (procd 1) --[9]--\u0026gt; (ash 142) 24[ 58.799449] Signal :: (kernel 0) --[1]--\u0026gt; (ash 142) ftrace and strace ftrace is really cool. I love and often use it. But it has a steep learning curve as much as its flexibility than most tracers. Not only that reason, but also roughly able to trace them at the early stage of boot or halt.\nstrace traces only one program at a time. That means you must execute it as many as you'd like to trace. NOT the whole system.\nThis strategy might be good for both linux distros we mainly use in laptops and embedded systems. But more comfy on the latter for a test. This is a rough idea rather than bad article like \u0026quot;this one is better than others\u0026quot;.\nI hope you get inspired a lot and would be happy to have emails if someone has good ideas more than mine :-)\nStay safe!\n","link":"https://www.ooseel.net/me/2020/12/tricky-signal-tracing-in-kernel/","section":"posts","tags":null,"title":"Tricky Signal Tracing in Kernel"},{"body":"I use my left pinky to jump back and forth in vim with cscope, ctags + vim comb a lot everyday. Especially ctrl + t, o, ] and so on. However, it has been hurt slightly. I thought that it might be by the use of the pinky a lot, so that looked for a solution in Google. Firstly, I could have modified my input method program a bit such that swap between Ctrl and Caps Lock, but felt frustrated all the steps code level to testing. At a random period of time looking for solutions, I just looked down, see my keyboard and found out there was a key saying \u0026quot;Switch layer\u0026quot;.\nI said \u0026quot;Yeh, that's it!\u0026quot;\nI am currently using Vortex Race 3 and it has it. It supports 4 switch layers and be able to customize user keymap in each one. So I swapped these two keys, Caps Lock and Ctrl. Yet I am still trying to get used to the new map, my pinky gets better. :-)\n    Let me say this, not all keyboards existed support this functionality. You should check it out first.\n","link":"https://www.ooseel.net/me/2020/08/vim-pinky-and-programmable-keyboard/","section":"posts","tags":null,"title":"Vim Pinky and Programmable Keyboard"},{"body":"","link":"https://www.ooseel.net/me/tags/gnome/","section":"tags","tags":null,"title":"Gnome"},{"body":"","link":"https://www.ooseel.net/me/tags/gtk+/","section":"tags","tags":null,"title":"GTK+"},{"body":"Hello, everyone!\nThere is a meetup named Cron-a-thon held by Ubuntu-KR Daejeon team every 2 weeks. However, I put the workshop on the table at the meetup 3 months ago. The administrators and I talked about the organization of an event for the beginners who were into how to build a GTK+ application in Python. That was the beginning of the workshop.\nBefore we talk about the workshop, let's look at goods a bit.\n    They are so cool, aren't they?! I had stickers from our community, 30 sheets of stickers that ordered and brochures. The workshop wasn't just only for talking about GTK+, but also I wanted audiences to get to know about our community, GNOME. What we do and who we are looking for. The brochure was for that. Stickers? Well...\nRoses are red Violets are blue Developers like stickers. - Unknown  The Workshop was about how to build a GTK+ application for the beginners as I said above. So it consisted of several sections.\n What and why GTK+ Basic principles Basic widgets (practice) Build a small project  The first and second sections talked about the foundation of GUI programming such as things behind GTK+ application, and rough ideas of Event-Driven Programming.\nIn my opinion, things behind GTK+ and how applications work are more significant than others. Once we have known what there are and how they work, we can clarify where we should examine for issues. For this reason, I wished they make sure of the foundation.\nD-Day (Jan, 13th) It was the day of the event, GTK+ workshop in Daejeon. I was really excited to see audiences. But on the other hand, I was nervous a bit!\nThe first and second sections talked about the foundation of GUI programming such as things behind GTK+ application, and rough ideas of Event-Driven Programming.\nIn my opinion, things behind GTK+ and how applications work are more significant than others. Once we have known what there are and how they work, we can clarify where we should examine for issues. For this reason, I wished they make sure of the foundation. Jan, 13th day\nIt was the day of the event, GTK+ workshop in Daejeon. I was really excited to see audiences. But on the other hand, I was nervous a bit!\nThey were really keeping an eye on the workshop and one more that, they found an issue in source code and fixed it themselves!\nAnyway, the workshop took about 4 hours. There was a critical issue I did not expect, but I think we were successfully finished!\nAbout Flatpak To me, this workshop was a kind of trial to use Flatpak as a development environment. You might know that preparing the environment for audiences is absolutely painful. We have to think out of everything like ... they could have all different versions even in the same linux distro, or library dependencies! I really didn't want them to feel such a pain while setting up.\n Using Virtual Machines like VirtualBox, VMware could be the one of the solutions, but GUI programs on that machines response slow. Also in the meantime, while I was preparing, I thought of Flatpak as another option. It was really cool. I did not need to take care of the dependencies at all. With pre-installed GNOME SDK and GNOME Builder, just done.\nProblems are always unpredictable - Me  One of them brought Ubuntu 16.04. He was done with SDK and Builder installation. But when he tried to run an application for the practice session, he got errors that could not run. For the workaround, he run them on his host machine instead of Flatpak.\nYet we should use Virtual Machines for providing the same environment. But I am sure that Flatpak will be there in the future.\nThanks to First, I would like to give BIG THANKS to Ubuntu-KR Daejeon team and GNOME community staffs. I couldn't have done this workshop without their helps. Also, 강천성 who is a student of CNU, he helped with printing out the brochures.\nThis organization was my first time. I was not enough, but I have learnt how I should be ready to give a speech. See you guys next time, Bye! :-)\n    ","link":"https://www.ooseel.net/me/2019/01/gtk-workshop-in-daejeon/","section":"posts","tags":["Linux","GTK+","Gnome"],"title":"GTK+ Workshop in Daejeon"},{"body":"","link":"https://www.ooseel.net/me/about/","section":"","tags":null,"title":""},{"body":"","link":"https://www.ooseel.net/me/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://www.ooseel.net/me/series/","section":"series","tags":null,"title":"Series"}]