<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Memnoth on Memnoth</title>
    <link>https://memnoth.github.io/</link>
    <description>Recent content in Memnoth on Memnoth</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 </copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to get your Realtek RTL8111/RTL8168 working</title>
      <link>https://memnoth.github.io/2017/06/26/how-to-get-your-realtek-rtl8111/rtl8168-working/</link>
      <pubDate>Mon, 26 Jun 2017 11:53:39 +0900</pubDate>
      
      <guid>https://memnoth.github.io/2017/06/26/how-to-get-your-realtek-rtl8111/rtl8168-working/</guid>
      <description>

&lt;h1 id=&#34;why-do-i-need-this-driver-anyway&#34;&gt;Why do I need this driver anyway?&lt;/h1&gt;

&lt;p&gt;많은 분들이 제게 &amp;ldquo;이게 왜 필요하죠? 리눅스에서 지원하지 않나요?&amp;hellip;&amp;rdquo; 라고 물어봅니다. 하지만 &lt;code&gt;RTL8111/RTL8168&lt;/code&gt;은 오픈 소스가 아니에요. 이제 왜 리눅스 커널에 포함되지 않는지 아시겠죠?&lt;br /&gt;
그래서 우리가 직접 빌드해야 된답니다.&lt;/p&gt;

&lt;h1 id=&#34;the-installation-methods&#34;&gt;The installation methods&lt;/h1&gt;

&lt;p&gt;Ubuntu/Debian에서 디바이스 드라이버를 컴파일하는 방법에 대해 글을 쓴 이후로 많은 것이 변했습니다. 그래서 오늘은 드라이버를 설치하기 위한 방법 2개를 소개하고자 합니다.&lt;/p&gt;

&lt;h1 id=&#34;the-automatic-way&#34;&gt;The automatic way&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;NOTE: 힌트를 준 &lt;code&gt;Liyu&lt;/code&gt;에게 고마움을 전합니다.&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;NOTE2: 인터넷 연결이 필요합니다. WLAN이나 USB 이더넷 카드를 이용해서 인터넷에 연결해주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ubuntu와 Debian의 저장소에는 우리가 설치할 드라이버가 포함되어 있습니다. Debian 유저라면 &lt;code&gt;non-free&lt;/code&gt; 패키지 소스를 활성화(Enable) 해야하고 Ubuntu 유저라면 &lt;code&gt;universe&lt;/code&gt; 패키지 소스를 활성화해야 합니다. &lt;em&gt;/etc/apt/sources.list&lt;/em&gt; 를 root 권한과 함께 텍스트 에디터로 열어서 수정해야 합니다.&lt;/p&gt;

&lt;h2 id=&#34;debian-이용자&#34;&gt;Debian 이용자&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;deb http://ftp.de.debian.org/debian/ jessie main contrib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 라인을 다음과 같이 변경하고 저장합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://ftp.de.debian.org/debian/ jessie main contrib non-free
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;저장소를 업데이트합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;ubuntu-이용자&#34;&gt;Ubuntu 이용자&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;deb http://de.archive.ubuntu.com/ubuntu/ xenial main restricted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 라인을 다음과 같이 변경하고 저장합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://de.archive.ubuntu.com/ubuntu/ xenial main restricted universe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;저장소를 업데이트합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 준비가 되었으니 아래 명령어를 이용하여 디바이스 드라이버를 설치합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install r8168-dkms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CPU 종류에 따라 디바이스 드라이버를 빌드하는데 소요되는 시간이 있습니다.&lt;br /&gt;
자동화 방법의 장점은 Kernel 업데이트가 생기면 &lt;em&gt;dkms&lt;/em&gt; 에 의해 &lt;code&gt;r8168&lt;/code&gt; 드라이버도 업데이트됩니다. 빌드가 끝나고 이더넷 카드를 사용할 수 있어야 하는데 그렇지 않다면 재부팅합니다.&lt;/p&gt;

&lt;h1 id=&#34;the-manual-way&#34;&gt;The manual way&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;NOTE: Manual 방식은 4.0 이상의 커널에서 테스트되었습니다.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-의존성-설치&#34;&gt;1. 의존성 설치&lt;/h3&gt;

&lt;p&gt;우선 인터넷에 연결되어 있어야 합니다. 물론 필요한 패키지를  Debian/Ubuntu DVD에서 찾을 수도 있습니다.&lt;br /&gt;
의존성 패키지를 설치하기 위해 아래의 명령어를 입력합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential linux-headers-$(uname -r)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-드라이버-코드-다운로드&#34;&gt;2. 드라이버 코드 다운로드&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.realtek.com.tw/downloads/downloadsView.aspx?Langid=1&amp;amp;PNid=13&amp;amp;PFid=5&amp;amp;Level=5&amp;amp;Conn=4&amp;amp;DownTypeID=3&amp;amp;GetDown=false#2&#34; target=&#34;_blank&#34;&gt;링크&lt;/a&gt;를 통하여 Realtek 홈페이지에서 공식 드라이버를 받을 수 있습니다. 커널 버전이 4.7 이상이면 &lt;code&gt;LINUX driver for kernel up to 4.7&lt;/code&gt;를 선택하고 아니면 &lt;code&gt;Linux driver for kernel 2.4.x (Support x86 and x64)&lt;/code&gt;를 선택합니다.&lt;/p&gt;

&lt;h3 id=&#34;3-블랙리스트에-r8169-드라이버-추가&#34;&gt;3. 블랙리스트에 r8169 드라이버 추가&lt;/h3&gt;

&lt;p&gt;시스템에 &lt;code&gt;r8168&lt;/code&gt; 드라이버가 없으면 r8169를 사용하게 됩니다. 하지만 RTL8168 이더넷 카드에서 r8169 드라이버는 불안정합니다.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; r8169가 로드되는 것을 막기 위하여 블랙리스트를 이용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@linux:~$ sudo sh -c &#39;echo blacklist r8169 &amp;gt;&amp;gt; /etc/modprobe.d/blacklist.conf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-소스코드-압축해제&#34;&gt;4. 소스코드 압축해제&lt;/h3&gt;

&lt;p&gt;드라이버를 다운로드하고 나서 압축을 풉니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@linux:~@ tar xfvj path/to/file.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE: 소스코드 파일 이름은 다를 수 있으니 주의하세요.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-컴파일-및-설치&#34;&gt;5. 컴파일 및 설치&lt;/h3&gt;

&lt;p&gt;압축해제된 폴더로 이동합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@linux:~$ cd path/to/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 스크립트를 이용하여 컴파일 및 설치 과정을 진행합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@linux:~/path/to/file$ sudo ./autorun.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;드라이버 빌드가 끝나고 올바르게 설치되었다면 아래와 같이 출력되어야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Check old driver and unload it.
rmmod r8169
Build the module and install
At main.c:222:
- SSL error:02001002:system library:fopen:No such file or directory: bss_file.c:175
- SSL error:2006D080:BIO routines:BIO_new_file:no such file: bss_file.c:178
sign-file: certs/signing_key.pem: No such file or directory
Backup r8169.ko
rename r8169.ko to r8169.bak
DEPMOD 4.4.0-31-generic
load module r8168
Updating initramfs. Please wait.
update-initramfs: Generating /boot/initrd.img-4.4.0-31-generic
Completed.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-드라이버-확인&#34;&gt;6. 드라이버 확인&lt;/h3&gt;

&lt;p&gt;마지막으로 드라이버가 올바르게 로드되었는지 확인합니다. 어떠한 오류도 없다면 아래와 같이 출력됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@linux:~$ lsmod | grep r8168
r8168                 491520  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이더넷 디바이스에서도 확인해봅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@linux:~$ sudo ethtool -i enp1s0
driver: r8168
version: 8.042.00-NAPI
firmware-version:
expansion-rom-version:
bus-info: 0000:07:00.0
supports-statistics: yes
supports-test: no
supports-eeprom-access: yes
supports-register-dump: yes
supports-priv-flags: no
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;로드되지 않았으면 시스템을 재부팅하고 다시 확인합니다.&lt;/p&gt;

&lt;h1 id=&#34;that-s-it&#34;&gt;That&amp;rsquo;s it&lt;/h1&gt;

&lt;p&gt;이제 Realtek 공식 드라이버를 이용할 준비가 되었습니다. 만약 궁금한 점이나 제안하고 싶은 것이 있다면 댓글로 알려주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;원문 &amp;ndash; &lt;a href=&#34;https://unixblogger.com/2016/08/11/how-to-get-your-realtek-rtl8111rtl8168-working-updated-guide/&#34; target=&#34;_blank&#34;&gt;How To get your Realtek RTL8111/RTL8168 working&lt;/a&gt; by Unixblogger&lt;br /&gt;
번역 &amp;ndash; Yi Soo, (Thomas) An&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;This means slow download rates, homepages taking hours to load and so on.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>An Easy Explaination Of First And Follow Sets</title>
      <link>https://memnoth.github.io/2017/06/20/an-easy-explaination-of-first-and-follow-sets/</link>
      <pubDate>Tue, 20 Jun 2017 13:27:00 +0900</pubDate>
      
      <guid>https://memnoth.github.io/2017/06/20/an-easy-explaination-of-first-and-follow-sets/</guid>
      <description>

&lt;p&gt;이 글은 James Brunskill씨가 작성한 First and Follow Sets에 대한 글입니다.&lt;br /&gt;
이 자릴 빌어 그에게 감사를 전합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;first-and-follw-sets&#34;&gt;First and Follw Sets&lt;/h1&gt;

&lt;p&gt;대학교에서 First and Follow sets을 처음 배울때 follow는 이해하기가 어려웠습니다. 따라서 제가 배운 규칙들을 다시 작성하였으며 도움이 되길 바랍니다. 이 규칙들이 올바른지 궁금할 것 입니다. 그래서 저는 한 강사님에게 수업에서 이 방법을 시도해 볼 것을 요청하였고 효과가 있다고 생각합니다. 궁금한 점이 있거나 무엇인가 제안하고 싶다면 자유롭게 메일&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;로 연락주시기 바랍니다.&lt;/p&gt;

&lt;h1 id=&#34;rules-for-first-sets&#34;&gt;Rules for First Sets&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;X가 terminal 이라면 First(X)는 X입니다.&lt;/li&gt;
&lt;li&gt;Production X → ε이 존재하면 ε을 first(X)에 추가하세요.&lt;/li&gt;
&lt;li&gt;Production X → Y1Y2..Yk가 존재하면 first(Y1Y2..Yk)를 first(X)에 추가하세요.&lt;/li&gt;
&lt;li&gt;First(Y1Y2..Yk)가 다음과 같다면..

&lt;ol&gt;
&lt;li&gt;First(Y1) (First(Y1)에 ε이 포함되지 않은 경우)&lt;/li&gt;
&lt;li&gt;또는 (First(Y1)에 ε이 포함)이 된다면 ε을 제외한 모든 First(Y1Y2..Yk)는 First(Y1)에 포함됩니다. 이는 First(Y2..Yk)에도 적용됩니다.&lt;/li&gt;
&lt;li&gt;ε이 First(Y1) First(Y2) .. First(Yk)에 포함이 되면 ε을 First(Y1Y2..Yk)에 추가하세요.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;rules-for-follow-sets&#34;&gt;Rules for Follow Sets&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Follow(S)에 $을 추가하세요. (S는 시작 심볼입니다.)&lt;/li&gt;
&lt;li&gt;Production A → aBb가 존재하면 ε을 제외한 모든 FIRST(b)를 FOLLOW(B)에 추가합니다.&lt;/li&gt;
&lt;li&gt;Production A → aB가 존재하면 FOLLOW(A)에 존재하는 모든 것을 FOLLOW(B)에 추가합니다.&lt;/li&gt;
&lt;li&gt;production A → aBb가 존재하고 FIRST(b)에 ε이 포함되면 FOLLOW(A)의 모든 것을 FOLLOW(B)에 추가합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;here-an-example-for-you-to-follow-through&#34;&gt;Here an example for you to follow through&lt;/h1&gt;

&lt;p&gt;Grammar는 다음과 같습니다.&lt;br /&gt;
이때 left-recursion을 없애는 것에 주의해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E → E + T | T  
T → T + F | F  
F → (E) | id  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;에서 left-recursion을 없애면 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E → TE&#39;  
E&#39; → +TE&#39;  
E&#39; → ε  
T → FT&#39;  
T&#39; → *FT&#39;  
T&#39; → ε  
F → (E)  
F → id  
&lt;/code&gt;&lt;/pre&gt;

&lt;table style=&#34;font-size:15px&#34;&gt;
&lt;tr&gt;
&lt;td width=25%&gt;First Sets&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td width=25%&gt;Follow Sets&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;First sets을 만들어야 하니 Set을 초기화합니다.&lt;/td&gt;
&lt;td&gt;FIRST(E) = {}&lt;br&gt;FIRST(E&#39;) = {}&lt;br&gt;FIRST(T) = {}&lt;br&gt;FIRST(T&#39;) = {}&lt;br&gt;FIRST(F) = {}&lt;/td&gt;
&lt;td&gt;Follow sets을 만들어야 하니 Set을 초기화합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {}&lt;br&gt;FOLLOW(E&#39;) = {}&lt;br&gt;FOLLOW(T) = {}&lt;br&gt;FOLLOW(T&#39;) = {}&lt;br&gt;FOLLOW(F) = {}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T&#39; → ε와 E&#39; → ε에 규칙 2번을 적용합니다.&lt;/td&gt;
&lt;td&gt;FIRST(E) = {}&lt;br&gt;FIRST(E&#39;) = {ε}&lt;br&gt;FIRST(T) = {}&lt;br&gt;FIRST(T&#39;) = {ε}&lt;br&gt;FIRST(F) = {}&lt;/td&gt;
&lt;td&gt;시작 심볼 E에 $를 추가합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$}&lt;br&gt;FOLLOW(E&#39;) = {}&lt;br&gt;FOLLOW(T) = {}&lt;br&gt;FOLLOW(T&#39;) = {}&lt;br&gt;FOLLOW(F) = {}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;E&#39; → +TE&#39;에 규칙 3번을 적용합니다.&lt;br&gt;이는 First(+TE&#39;)에 속한 모든 것을 First(E&#39;)에 추가함을 의미합니다.&lt;br&gt;규칙 1번에 의해 +을 First(E&#39;)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FIRST(E) = {}&lt;br&gt;FIRST(E&#39;) = {+,ε}&lt;br&gt;FIRST(T) = {}&lt;br&gt;FIRST(T&#39;) = {ε}&lt;br&gt;FIRST(F) = {}&lt;/td&gt;
&lt;td&gt;E&#39; → +TE&#39;에 규칙 2번을 적용합니다.&lt;br&gt;이는 First(E&#39;)의 원소 중 ε을 제외한 모든 것이 Follow(T)에 있어야 함을 뜻합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$}&lt;br&gt;FOLLOW(E&#39;) = {}&lt;br&gt;FOLLOW(T) = {+}&lt;br&gt;FOLLOW(T&#39;) = {}&lt;br&gt;FOLLOW(F) = {}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T&#39; → *FT&#39;에 규칙 3번을 적용합니다.&lt;br&gt;이는 First(*FT&#39;)에 속한 모든 것을 First(T&#39;)에 추가함을 의미합니다.&lt;br&gt;규칙 1번에 의해 *을 First(T&#39;)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FIRST(E) = {}&lt;br&gt;FIRST(E&#39;) = {+,ε}&lt;br&gt;FIRST(T) = {}&lt;br&gt;FIRST(T&#39;) = {*,ε}&lt;br&gt;FIRST(F) = {}&lt;/td&gt;
&lt;td&gt;E → TE&#39;에 규칙 3번을 적용합니다.&lt;br&gt;Follow(E)의 모든 원소를 Follow(E&#39;)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$}&lt;br&gt;FOLLOW(E&#39;) = {$}&lt;br&gt;FOLLOW(T) = {+}&lt;br&gt;FOLLOW(T&#39;) = {}&lt;br&gt;FOLLOW(F) = {}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Terminal로 시작하는 Production F → (E)와 F → id에 규칙 3번을 적용합니다.&lt;/td&gt;
&lt;td&gt;FIRST(E) = {}&lt;br&gt;FIRST(E&#39;) = {+,ε}&lt;br&gt;FIRST(T) = {}&lt;br&gt;FIRST(T&#39;) = {*,ε}&lt;br&gt;FIRST(F) = {&#39;(&#39;,id}&lt;/td&gt;
&lt;td&gt;T → FT&#39;에 규칙 3번을 적용합니다.&lt;br&gt;Follow(T)의 모든 원소를 Follow(T&#39;)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$}&lt;br&gt;FOLLOW(E&#39;) = {$}&lt;br&gt;FOLLOW(T) = {+}&lt;br&gt;FOLLOW(T&#39;) = {+}&lt;br&gt;FOLLOW(F) = {}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T → FT&#39;에 규칙 3번을 적용합니다.&lt;br&gt;First(FT&#39;)를 First(T)에 추가합니다.&lt;br&gt;First(F)는 ε을 포함하지 않으므로 First(FT&#39;)는 First(F)와 같습니다.&lt;/td&gt;
&lt;td&gt;FIRST(E) = {}&lt;br&gt;FIRST(E&#39;) = {+,ε}&lt;br&gt;FIRST(T) = {&#39;(&#39;,id}&lt;br&gt;FIRST(T&#39;) = {*,ε}&lt;br&gt;FIRST(F) = {&#39;(&#39;,id}&lt;/td&gt;
&lt;td&gt;T&#39; →*FT&#39;에 규칙 2번을 적용합니다.&lt;br&gt;ε을 제외한 First(T&#39;)를 Follow(F)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$}&lt;br&gt;FOLLOW(E&#39;) = {$}&lt;br&gt;FOLLOW(T) = {+}&lt;br&gt;FOLLOW(T&#39;) = {+}&lt;br&gt;FOLLOW(F) = {*}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;E → TE&#39;에 규칙 3번을 적용합니다.&lt;br&gt;First(TE&#39;)를 First(E)에 추가합니다.&lt;br&gt;First(T)는 ε을 포함하지 않으므로 First(TE&#39;)는 First(T)와 같습니다.&lt;/td&gt;
&lt;td&gt;FIRST(E) = {&#39;(&#39;,id}&lt;br&gt;FIRST(E&#39;) = {+,ε}&lt;br&gt;FIRST(T) = {&#39;(&#39;,id}&lt;br&gt;FIRST(T&#39;) = {*,ε}&lt;br&gt;FIRST(F) = {&#39;(&#39;,id}&lt;/td&gt;
&lt;td&gt;F → (E)에 규칙 2번을 적용합니다.&lt;br&gt;First(&#39;)&#39;)의 모든 것을 Follow(E)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$,)}&lt;br&gt;FOLLOW(E&#39;) = {$}&lt;br&gt;FOLLOW(T) = {+}&lt;br&gt;FOLLOW(T&#39;) = {+}&lt;br&gt;FOLLOW(F) = {*}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;E → TE&#39;에 규칙 3번을 적용합니다.&lt;br&gt;Follow(E)의 모든 원소를 Follow(E&#39;)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$,)}&lt;br&gt;FOLLOW(E&#39;) = {$,)}&lt;br&gt;FOLLOW(T) = {+}&lt;br&gt;FOLLOW(T&#39;) = {+}&lt;br&gt;FOLLOW(F) = {*}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;E&#39; → +TE&#39;에 규칙 4번을 적용합니다.&lt;br&gt;Follow(E&#39;)의 모든 원소를 Follow(T)에 추가합니다. (First(E&#39;)는 ε포함)&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$,)}&lt;br&gt;FOLLOW(E&#39;) = {$,)}&lt;br&gt;FOLLOW(T) = {+,$,)}&lt;br&gt;FOLLOW(T&#39;) = {+}&lt;br&gt;FOLLOW(F) = {*}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;T → FT&#39;에 규칙 3번을 적용합니다.&lt;br&gt;Follow(T)의 모든 원소를 Follow(T&#39;)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$,)}&lt;br&gt;FOLLOW(E&#39;) = {$,)}&lt;br&gt;FOLLOW(T) = {+,$,)}&lt;br&gt;FOLLOW(T&#39;) = {+,$,)}&lt;br&gt;FOLLOW(F) = {*}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;T&#39; → *FT&#39;에 규칙 4번을 적용합니다.&lt;br&gt;Follow(T&#39;)의 모든 원소를 Follow(F)에 추가합니다.&lt;/td&gt;
&lt;td&gt;FOLLOW(E) = {$,)}&lt;br&gt;FOLLOW(E&#39;) = {$,)}&lt;br&gt;FOLLOW(T) = {+,$,)}&lt;br&gt;FOLLOW(T&#39;) = {+,$,)}&lt;br&gt;FOLLOW(F) = {*,+,$,)}&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;원문 &amp;ndash; &lt;a href=&#34;https://www.jambe.co.nz/UNI/FirstAndFollowSets.html&#34; target=&#34;_blank&#34;&gt;An Easy Explaination Of First And Follow Sets&lt;/a&gt; by James Brunskill&lt;br /&gt;
번역 &amp;ndash; Yi Soo, (Thomas) An&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;보안상 James Brunskill씨의 사이트로 대체합니다; &lt;a href=&#34;https://jmb.nz/&#34; target=&#34;_blank&#34;&gt;https://jmb.nz/&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>read system call overhead and file hole</title>
      <link>https://memnoth.github.io/2017/01/30/read-system-call-overhead-and-file-hole/</link>
      <pubDate>Mon, 30 Jan 2017 20:44:40 +0900</pubDate>
      
      <guid>https://memnoth.github.io/2017/01/30/read-system-call-overhead-and-file-hole/</guid>
      <description>

&lt;h4 id=&#34;이-글은-advanced-programming-in-the-unix-environment의-4-6-연습문제에-관한-내용입니다&#34;&gt;&lt;em&gt;이 글은 Advanced Programming in the Unix Environment의 4.6 연습문제에 관한 내용입니다.&lt;/em&gt;&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;4.6 연습문제의 내용은 다음과 같다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cp(1)처럼 파일을 복사하되, 구멍&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;이 있는 파일을 복사하느 경우 출력 파일에 0 바이트들을 기록하지 않는 유틸리티를 작성하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 연습문제의 키 포인트는 파일의 구멍이 &lt;code&gt;\0&lt;/code&gt;로 채워져있다는 것이다.&lt;/p&gt;

&lt;p&gt;복사될 파일의 데이터는 다음과 같으며 크기는 16394 byte 이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000000   a   b   c   d   e   f   g   h   i   j  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
*
0040000   A   B   C   D   E   F   G   H   I   J
0040012
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;해당 유틸리티를 간단하게 작성하면 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  int fd_in, fd_out, n;
  char buf;

  /* 기타 예외처리와 open 함수를 이용해 파일을 열었다고 가정 */

  while ((n = read(fd_in, &amp;amp;buf, 1)) &amp;gt; 0) {
    if (buf == &#39;\0&#39;)
      continue;
    write(fd_out, &amp;amp;buf, n);
  }

  /* 기타 처리 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하지만 위 코드에는 단점이 존재하는데 파일로 부터 데이터를 1 바이트씩 읽어오므로 read 호출비용이 너무 크다는 것이다. 해당 코드를 uftrace&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;로 트레이싱해보면 실행시간이 다음과 같이 나온다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.501 us [11287] | __monstartup();
  1.203 us [11287] | __cxa_atexit();
           [11287] | main() {

             ... 

  0.6xx us [11287] |   read(); /* 파일 크기만큼 호출 */

             ...

 18.097 ms [11287] | } /* main */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;read 호출이 16394번 일어나 실행시간이 18.097 ms 임을 확인할 수 있다. 이는 해당 코드가 불 필요하게 read를 호출하며 오버헤드를 생성하고 있음을 의미한다. 따라서 다음과 같이 buffer를 이용하여 시스템 호출 비용을 줄여보고자 한다.&lt;/p&gt;

&lt;p&gt;아래는 buffer를 이용하여 블럭단위로 데이터를 읽어오고 구멍을 제거하는 코드이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define BUFSIZE 4096

int
rm_hole(char *pbuf, int n)
/* 배열 중간중간에 존재하는 구멍을 제거하고 배열의 앞쪽으로 정렬
 * pbuf : a b c \0 \0 \0 b c a \0 \0 c ...
 *        ^ cur
 */
{
  /* cur: 구멍이 아닌 데이터의 마지막 위치를 가짐 */
  int i, cur = 0;

  for (i = 0; i &amp;lt; n; i++) {
    if (pbuf[i] != &#39;\0&#39;) {
      if (i != cur)
        pbuf[cur] = pbuf[i];
      cur++;
    }
  }
  /* pbuf : a b c b c a c \0 \0 ... 
   *                      ^ cur
   */

  /* write 호출시 정렬된 배열의 cur값 만큼만 파일 쓰기를 하기 위함 */
  return cur;
}

int
main(int argc, char *argv[])
{
  int fd_in, fd_out, n;
  char buf[BUFSIZE];

  /* 기타 예외처리와 open 함수를 이용하여 파일을 열었다고 가정 */

  while ((n = read(fd_in, buf, BUFSIZE)) &amp;gt; 0) {
    write(fd_out, buf, rm_hole(buf, n));
  }

  /* 기타 처리 */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 uftrace를 이용하여 실행시간을 확인해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.467 us [12932] | __monstartup();
  0.956 us [12932] | __cxa_atexit();
           [12932] | main() {
             
             ...

  4.300 us [12932] | read();
 20.948 us [12932] | rm_hole();
 11.663 us [12932] | write();
  
      /* read, rm_hole, write가 4번 더 호출 */

             ...

140.466 us [12932] | } /* main */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;read를 한 번 호출할 때마다 4096 byte 읽으므로 총 5번 호출된다. 실행 시간은 위와 같이 140.47 us으로 단축되었다.&lt;/p&gt;

&lt;p&gt;또한 구멍(&lt;code&gt;\0&lt;/code&gt;)이 제거된 파일은 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000000   a   b   c   d   e   f   g   h   i   j   A   B   C   D   E   F
0000020   G   H   I   J
0000024 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;요약&#34;&gt;요약&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;read (System call)은 비용이 크므로 남용하지 말고 buffer 메커니즘을 이용하자.&lt;/li&gt;
&lt;li&gt;파일의 오프셋을 크기보다 키우면 &lt;code&gt;\0&lt;/code&gt;로 채워진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;현재 파일의 오프셋이 파일 크기보다 크게 설정될 수 있다. 이때 write 함수를 호출하면 파일의 크기는 오프셋에 맞게 늘어나고 빈 공간은 &lt;code&gt;\0&lt;/code&gt; 으로 쓰여진다. 이러한 공간을 구멍이라 말한다.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;C/C++로 작성된 프로그램의 실행 상태를 트레이싱하고 분석하는 툴, &lt;a href=&#34;https://github.com/namhyung/uftrace&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Flask-Register</title>
      <link>https://memnoth.github.io/project/flask-register/</link>
      <pubDate>Thu, 29 Dec 2016 00:13:07 +0900</pubDate>
      
      <guid>https://memnoth.github.io/project/flask-register/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Example Talk</title>
      <link>https://memnoth.github.io/talk/example-talk/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/talk/example-talk/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>YouCompleteMe - libtinfo.so.5 not found</title>
      <link>https://memnoth.github.io/2016/07/24/ycm-libtinfo-so-5-not-found/</link>
      <pubDate>Sun, 24 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2016/07/24/ycm-libtinfo-so-5-not-found/</guid>
      <description>&lt;p&gt;Laptop에 Fedora 24를 설치하고 YouCompleteMe&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;를 인스톨했으나 &lt;em&gt;SHUTTING DOWN&lt;/em&gt; 오류를 출력하며 정상적으로 실행되지 않았다.&lt;br /&gt;
&lt;strong&gt;:YcmToggleLogs stderr&lt;/strong&gt;를 통하여 디버깅을 해보니 시스템에서 &lt;code&gt;libtinfo.so.5&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;를 찾지 못해 발생한 예외였다.&lt;/p&gt;

&lt;p&gt;설치된 패키지가 있나 확인해보니 6.0.5 버전으로 존재했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dnf list installed | grep ncurses
ncurses.x86_64                         6.0-5.20160116.fc24      @koji-override-0
ncurses-base.noarch                    6.0-5.20160116.fc24      @koji-override-0
ncurses-libs.x86_64                    6.0-5.20160116.fc24      @koji-override-0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lib64 디렉터리에서도 &lt;code&gt;libtinfo.so.6&lt;/code&gt;을 찾을 수 있다, 나는 libtinfo.so.5를 원하는데&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -l /lib64/libtinfo*
lrwxrwxrwx. 1 root root     15  4월  8 19:33 /lib64/libtinfo.so.6 -&amp;gt; libtinfo.so.6.0
-rwxr-xr-x. 1 root root 180192  4월  8 19:33 /lib64/libtinfo.so.6.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;물론 5까지 지원하는 &lt;code&gt;ncurses-compat-libs&lt;/code&gt;를 설치해도 되지만 심볼릭 링크를 이용해서 처리했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo ln -s /lib64/libtinfo.so.6.0 /lib64/libtinfo.so.5

$ ls -l /lib64/libtinfo*
lrwxrwxrwx. 1 root root     15  7월 24 02:06 libtinfo.so.5 -&amp;gt; libtinfo.so.6.0
lrwxrwxrwx. 1 root root     15  4월  8 19:33 libtinfo.so.6 -&amp;gt; libtinfo.so.6.0
-rwxr-xr-x. 1 root root 180192  4월  8 19:33 libtinfo.so.6.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 vim을 실행해보면 &lt;em&gt;SHUTTING DOWN&lt;/em&gt; 오류는 출력되지 않는다.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;vim에서 사용할 수 있는 우수한 code completion engine이다. &lt;a href=&#34;https://github.com/Valloric/YouCompleteMe&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;libtinfo는 ncurses 라이브러리 파일이다.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Learning MSP430F5529 - # Interrupt</title>
      <link>https://memnoth.github.io/2016/07/10/learning-msp430f5529-interrupt/</link>
      <pubDate>Sun, 10 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2016/07/10/learning-msp430f5529-interrupt/</guid>
      <description>

&lt;h4 id=&#34;이-글은-인터럽트-예제를-분석한-글이다-어느-누군가에게-도움이-되길&#34;&gt;&lt;em&gt;이 글은 인터럽트 예제를 분석한 글이다, 어느 누군가에게 도움이 되길&amp;hellip;&lt;/em&gt;&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;아래 코드는 &lt;a href=&#34;https://ti.com&#34; target=&#34;_blank&#34;&gt;ti.com&lt;/a&gt;에서 제공하는 인터럽트 예제코드&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;...

#define RED_LED P1OUT   // On-board RED led.

int main(void)
{
    P1DIR |= 0x01;      // Set direction OUT the led.
    TA0CCTL0 = CCIE;
    TA0CCR0 = 50000;
    TA0CTL = TASSEL_2 + MC_1 + TACLR;

    __bis_SR_register(LPM0_bits + GIE);
}

...

#pragma vector=TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void)
{
    RED_LED ^= 0x01;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GIE&lt;/code&gt; - General interrupt enable의 약자로 MCU의 인터럽트 허용여부를 결정한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LPM0_bits&lt;/code&gt; - CPUOFF 값에 매핑되어 있다, 해당 비트가 1로 설정되면 CPU는 off 상태로 변경된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__bis_SR_register()&lt;/code&gt; - CPU의 SR&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;를 제어하는 함수이다, 해당 레지스터는 CPU core에 존재하며 CPU 연산 결과에 대한 상태를 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
컴파일하고 MSP430F5529의 메모리를 디버깅해보면 &lt;code&gt;__bis_SR_register&lt;/code&gt; 함수를 실행하고 GIE bit가 enable되는 순간부터 TA0R&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 레지스터가 TA0CCR0&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; 레지스터의 값과 비교하며 50000까지 증가한다.&lt;br /&gt;
상태 레지스터를 디버깅해보면 &lt;strong&gt;CPUOFF&lt;/strong&gt; bit가 1로 세팅되어 있으므로 ISR&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;만 계속 처리하고 있음을 알게된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;코드를 아래와 같이 변경하고 다시 실행하면 while 루틴과 번갈아가며 처리함을 알 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;...

#define RED_LED P1OUT       // on-board RED led.
#define GREEN_LED P4OUT     // on-board GREEN led.

int main(void)
{
    P1DIR |= (1 &amp;lt;&amp;lt; 0);      // set direction OUT the RED led.
    P4DIR |= (1 &amp;lt;&amp;lt; 7);      // set direction OUT the GREEN led.
    TA0CCTL0 = CCIE;
    TA0CCR0 = 50000;
    TA0CTL = TASSEL_2 + MC_1 + TACLR;

    __bis_SR_register(GIE);

    while (1)
    {
        int i;

        GREEN_LED ^= (1 &amp;lt;&amp;lt; 7);
        for (i = 0; i &amp;lt; 30000; i++);
    }
}

...

#pragma vector=TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void)
{
    RED_LED ^= 0x01;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재미있는건 TA0R 레지스터 값이 증가할 때 전혀 CPU core 레지스터를 사용하지 않는다..!&lt;br /&gt;
또한 SR 전체인지, GIE bit인지는 모르겠지만 GIE가 0으로 설정되고 다른 ISR 호출을 허용하지 않는다.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;MSP430F55xx_ta0_02.c
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Status Register
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Timer_A0 Counter Register
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Timer_A0 Capture/Compare Control 0 Register
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;Interrupt Service Routine
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>비글본 블랙에서의 Dynamic Linking 오류</title>
      <link>https://memnoth.github.io/2016/06/24/dynamic-linking-error-on-bbb/</link>
      <pubDate>Fri, 24 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2016/06/24/dynamic-linking-error-on-bbb/</guid>
      <description>&lt;p&gt;임베디드 시스템에선 코드 작성 및 컴파일을 빠르게 하기 위해 Host PC와 Target board를 NFS로 연결하여 Host PC에서 컴파일 작업을 하고, Target board에서는 실행시키는 구조로 개발환경을 빌드한다.&lt;/p&gt;

&lt;p&gt;NFS 개발환경을 설정한 다음 arm gcc를 이용하여 컴파일을 했음에도 불구하고 &lt;code&gt;No such file or directory&lt;/code&gt; 오류가 발생하였다.&lt;br /&gt;
계정 권한, 파일 권한, Host PC의 mount 권한까지 모두 확인하였지만 잘못된 부분이 없었기에 무척 난감했는데 Dynamic Linking이 원인이였다.&lt;/p&gt;

&lt;p&gt;test가 실행파일이라 가정하고 &lt;code&gt;file&lt;/code&gt; 명령어를 이용하여 확인해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, for GNU/Linux 2.6.16, not stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/lib/&lt;strong&gt;ld-linux.so.3&lt;/strong&gt;는 프로그램이 메모리에 적재되는 시점에서 실행에 필요한 라이브러리를 링킹해주는 파일이다.&lt;br /&gt;
Host PC에서 프로그램 링킹은 &lt;strong&gt;ld-linux.so.3&lt;/strong&gt;가 담당하지만 비글본 블랙에서의 링킹은 /lib/&lt;code&gt;ld-linux-armhf.so.3&lt;/code&gt;이 담당한다.&lt;br /&gt;
비글본 블랙에서 &lt;strong&gt;ld-linux.so.3&lt;/strong&gt;를 찾을 수 없으니 실행이 되지 않았던 것인데 그렇다고 &lt;code&gt;ld-linux-armhf.so.3&lt;/code&gt;를 &lt;strong&gt;ld-linux.so.3&lt;/strong&gt;로 바꾸면 안된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ld-linux-armhf.so.3&lt;/code&gt;를 링크하는 &lt;strong&gt;ld-linux.so.3&lt;/strong&gt; 심볼릭 링크를 생성시키면 올바르게 동작한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ln -s /lib/ld-linux-armhf.so.3 /lib/ld-linux.so.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;비글본 블랙에서 위의 명령어로 &lt;strong&gt;ld-linux.so.3&lt;/strong&gt; 심볼릭 링크를 생성하고 &lt;code&gt;./test&lt;/code&gt;로 다시 실행해보자.&lt;br /&gt;
이젠 제대로 실행한다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mmap을 이용하여 GPIO 제어하기 - #1. Clock Enabling</title>
      <link>https://memnoth.github.io/2016/05/19/beagleboard-handle-gpio-by-mmap-01/</link>
      <pubDate>Thu, 19 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2016/05/19/beagleboard-handle-gpio-by-mmap-01/</guid>
      <description>

&lt;h4 id=&#34;아래-가이드는-c-언어와-linux에-능숙하고-computer-organization-microprocessor를-수강한-적-있는-학부생에게-추천합니다&#34;&gt;&lt;em&gt;아래 가이드는 C 언어와 Linux에 능숙하고 Computer Organization, Microprocessor를 수강한 적 있는 학부생에게 추천합니다.!&lt;/em&gt;&lt;/h4&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;왜-mmap을-이용하여-direct로-접근하나요&#34;&gt;왜 mmap을 이용하여 direct로 접근하나요?&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;The memory-mapping method allows you to directly access the registors that control the&lt;br /&gt;
GPIOs. Memory-mapping is very fast (about 1000 times faster than file I/O!), but only&lt;br /&gt;
processes with root permissions can use it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;책&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;에 따르면 memory-mapping 함수는 register에 직접 접근하도록 하며, 이는 &lt;code&gt;file I/O&lt;/code&gt; 방식보다 1000배는 빠르다고 합니다.&lt;/p&gt;

&lt;p&gt;BeagleBone Black의 GPIO는 기본적으로 disable 되어 있는데, 이를 활성화는 방법에는 2가지가 있습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SYSFS를 이용한 GPIO export.&lt;/li&gt;
&lt;li&gt;Register를 이용하여 직접 clock을 enable 하는 것.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서는 C 코드를 이용하여 register를 직접 제어하는 것에 포커스를 맞추겠습니다.&lt;br /&gt;
(SYSFS를 이용한 GPIO는 Beagleboard 홈페이지에 가면 친절하게 설명해줍니다)&lt;/p&gt;

&lt;p&gt;들어가기에 앞서 아래의 준비물이 필요합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0ahUKEwiZjbzk3ObMAhXC3KYKHeorDmYQFggcMAA&amp;amp;url=http%3A%2F%2Fwww.ti.com%2Flit%2Fug%2Fspruh73m%2Fspruh73m.pdf&amp;amp;usg=AFQjCNGGBH3-5NJnlA7Plnk3BhbVi_u77g&amp;amp;sig2=IK-nMfK0scQli5VemGRPPA&amp;amp;bvm=bv.122448493,d.dGY&#34; target=&#34;_blank&#34;&gt;AM335x Sitara Processors, Technical Reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CircuitCo/BeagleBone-Black/blob/master/BBB_SRM.pdf&#34; target=&#34;_blank&#34;&gt;BeagleBone Black System Reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/derekmolloy/boneDeviceTree/tree/master/docs&#34; target=&#34;_blank&#34;&gt;Derek Molloy&amp;rsquo;s Header Table Reference&lt;/a&gt; - both P8, and P9&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주로 Technical Reference Manual(이하 TRM)과 Header Table 문서를 참조하니 GPIO PIN 개념을 이해하고 TRM에서 register 정보를 찾을 수 있어야 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;register를-이용하여-clock을-enable-하기&#34;&gt;Register를 이용하여 clock을 enable 하기&lt;/h3&gt;

&lt;p&gt;리눅스는 대부분의 device를 파일로 추상화하여 제공합니다, 모듈화가 아주 잘 되어 있죠.&lt;br /&gt;
Device를 파일로 접근한다면 모든 처리 루틴을 아래와 같이 쉽게 생각할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;파일을 연다.&lt;/li&gt;
&lt;li&gt;파일에 데이터를 쓴다.&lt;/li&gt;
&lt;li&gt;파일을 닫는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;우리는 메모리에 직접 접근하여 register에 데이터를 쓰기(&lt;strong&gt;write&lt;/strong&gt;)할 것이므로 메모리를 추상화한 &lt;code&gt;/dev/mem&lt;/code&gt;을 이용할 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;...
fd = open(&amp;quot;/dev/mem&amp;quot;, O_RDWR|O_SYNC);

/* 기타 처리 루틴 ~ */

gpio_addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_BASE_ADDR);

*(gpio_addr + led_addr) = 0x01;     // LED를 On하는 로직이라 가정.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/dev/mem&lt;/code&gt;을 오픈하고 &lt;code&gt;mmap()&lt;/code&gt;을 호출하는 것 까진 좋으나 mapped memory를 통하여 값에 접근하려면 아마도 실패할 것입니다.&lt;br /&gt;
이는 GPIO의 clock이 기본적으로 disable 되어 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;Patricia 씨가 구글 그룹스에 남긴 글입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;일단 그건 clock 문제야, 우리가 BeagleBone Black을 부팅할 때 GPIO 1, 2, 그리고 3의 clocking system은 비활성화 되버려 (GPIO 0은 항상 활성 상태).&lt;/p&gt;

&lt;p&gt;따라서 다음과 같은 방법이 있는데:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pin export 하기 (and then the system enables the clock automatically)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CM_PER_GPIO#_CLKCTRL 레지스터의 일부 bits 수정하기 (TRM의 CM_PER 페이지 참조)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;mdash; Patricia N.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 CM_PER_GPIO2_CLKCTRL을 활성화하기 위해 TRM 문서의 CM_PER_GPIO2_CLKCTRL&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;의 &lt;code&gt;MODULEMODE&lt;/code&gt;을 확인해야 합니다.&lt;br /&gt;
해당 register의 값을 2로 수정하므로써 clock이 enable 되는 것입니다.&lt;/p&gt;

&lt;p&gt;아래 소스코드를 분석하여 확실하게 이해하세요.&lt;br /&gt;
(간단하게 작성하였으므로 완벽하게 동작하지 않습니다.!)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define CM_PER_BASE 0x44E00000

#define CM_PER_GPIO1 0xAC
#define CM_PER_GPIO2 0xB0
#define CM_PER_GPIO3 0xB4

#define MODE_ENABLE 0x2

void init_GPIO_enable(int fd);

int main(void)
{
    ...

    init_GPIO_enable(mem_fd);

    ...
}

void init_GPIO_enable(int fd)
{
    ...

    // CM_PER_BASE 주소를 기반으로 memory mapped 합니다.
    cm_per_addr = (char *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, CM_PER_BASE);

    ...

    // CM_PER_GPIO2의 오프셋 주소의 값을 수정하여 Enable 합니다. 
    *(cm_per_addr + CM_PER_GPIO2) = MODE_ENABLE;

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;GPIO_OE&lt;/code&gt;, &lt;code&gt;GPIO_DATAIN&lt;/code&gt;, &lt;code&gt;GPIO_DATAOUT&lt;/code&gt;을 이용하여 값을 읽고 쓸수 있습니다.&lt;br /&gt;
한번 enable 하면 Process를 종료하더라도 해당 register의 값은 변하지 않습니다.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;https://www.amazon.com/Android-beaglebone-black-andrew-henderson-ebook&#34; target=&#34;_blank&#34;&gt;Android for the BeagleBone Black&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;&lt;a href=&#34;http://beagleboard.org/Community/Forums?place=msg%2Fbeagleboard%2FOYFp4EXawiI%2F4T1CsRpjAQAJ&#34; target=&#34;_blank&#34;&gt;구글 그룹스&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;1196 page
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>What is Copy-On-Write?</title>
      <link>https://memnoth.github.io/2016/05/17/what-is-copy-on-write/</link>
      <pubDate>Tue, 17 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2016/05/17/what-is-copy-on-write/</guid>
      <description>&lt;p&gt;&lt;em&gt;Copy-On-Write&lt;/em&gt; 란 folk()를 이용하여 Child Process를 생성하는 시점에서는 Parent의 메모리를 참조하다가 Child Process의 Context가 변경될 때 메모리를 복사하는 메커니즘이다.&lt;/p&gt;

&lt;p&gt;아래의 코드가 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int pid, temp = 1;
pid = folk();

if (pid == 0)
{
    printf(&amp;quot;I&#39;m a child!\n&amp;quot;);
    temp = 2;
}
else if (pid &amp;gt; 0)
{
    printf(&amp;quot;I&#39;m a parent!\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;folk()가 실행되고 나서 메모리는 아래의 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://memnoth.github.io/img/cow/cow01.png&#34; alt=&#34;cow1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스는 각자의 공간을 가지고 있다고 배웠지만 Modern Operating System 들은 메모리 자원을 효율적으로 관리/사용하기 위해 COW 메커니즘을 이용한다.&lt;br /&gt;
Context가 변경되지 않는다면 PC(Program Counter)/Registers/Stack/Code/Data가 모두 똑같으므로 같은 메모리를 참조하다가 &lt;code&gt;temp = 2&lt;/code&gt;를 만나는 순간 Child Process의 Instance는 변경되므로 아래처럼 변경된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://memnoth.github.io/img/cow/cow02.png&#34; alt=&#34;cow2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;temp = 2&lt;/code&gt;가 Space 3의 Context라 가정하면 Child Process를 위한 Space 3가 생성되고 Copy된다.&lt;/p&gt;

&lt;p&gt;디테일한 메커니즘은 더 복잡하다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Designated Initializer in C</title>
      <link>https://memnoth.github.io/2015/10/11/designated-initializer-in-c/</link>
      <pubDate>Sun, 11 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2015/10/11/designated-initializer-in-c/</guid>
      <description>&lt;p&gt;Designated Initializer는 C99에서 표준화된 문법으로 아래와 같이 배열의 초기화가 가능하다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;int arr[10] = { [4] = 31, 32, [1] = 0, 1, 2, 3 };&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그런데 GCC 컴파일러에서 C89(as C90) 표준으로 컴파일해도 오류없이 컴파일이 가능했다..!&lt;br /&gt;
왜 가능한지 궁금하여 검색하던 중에 GCC 문서에서 그 내용을 찾을 수 있었다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In ISO C99 you can give the elements in any order, specifying the array indices
or structure field names they apply to, and GNU C allows this an extension in
C90 mode as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GCC 컴파일러에선 C90 표준까지도 지원하도록 확장되었다고 한다.&lt;/p&gt;

&lt;p&gt;모든 컴파일러가 이러한 문법을 지원하는 것은 아니니 혼란스러워 하지 말아야 한다.!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Keep the spirit of C</title>
      <link>https://memnoth.github.io/2015/10/09/keep-the-spirit-of-c/</link>
      <pubDate>Fri, 09 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2015/10/09/keep-the-spirit-of-c/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Trust the programmer.&lt;br /&gt;
프로그래머를 믿을 것.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t prevent the programmer from doing what needs to be done.&lt;br /&gt;
프로그래머가 사용하는 방법을 제지하지 말 것.&lt;/li&gt;
&lt;li&gt;Keep the language small and simple.&lt;br /&gt;
작고 간단한 언어로 유지할 것.&lt;/li&gt;
&lt;li&gt;Provide only one way to do an operation.&lt;br /&gt;
하나의 명령에 하나의 방법만 제시할 것.&lt;/li&gt;
&lt;li&gt;Make it fast, even if it is not guaranteed to be portable.&lt;br /&gt;
이식성을 포기하더라도 빠르게 만들 것.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C가 가진 자율성과 목적에 대한 이해가 있어야 올바르게 사용할 수 있다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Babelian</title>
      <link>https://memnoth.github.io/project/babelian/</link>
      <pubDate>Sat, 11 Jul 2015 00:08:45 +0900</pubDate>
      
      <guid>https://memnoth.github.io/project/babelian/</guid>
      <description></description>
    </item>
    
    <item>
      <title>How to Get Your Questions Answered</title>
      <link>https://memnoth.github.io/2015/05/24/how-to-get-your-questions-answered/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2015/05/24/how-to-get-your-questions-answered/</guid>
      <description>

&lt;h2 id=&#34;introduce&#34;&gt;Introduce&lt;/h2&gt;

&lt;p&gt;사람들은 왜 당신의 질문에 답변하지 않는 걸까?&lt;br /&gt;
이 글은 당신의 시간을 절약하며, 빠른 답변을 얻을 수 있도록 도와줄지도 모른다.&lt;/p&gt;

&lt;h2 id=&#34;당신은-왜-답변-받지-못하는-걸까&#34;&gt;당신은 왜 답변 받지 못하는 걸까?&lt;/h2&gt;

&lt;p&gt;상대방의 입장에서 당신의 질문을 객관적으로 살펴볼 필요가 있다.&lt;br /&gt;
아마 다음과 같은 공통된 문제점을 가지고 있을 것이다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;질문이 너무 광범위하다.
당신의 질문이 광범위하고 추상적이라 디테일하게 다시 물어봐야 한다. 그냥 안 물어보고 신경 끈다.&lt;/li&gt;
&lt;li&gt;불필요한 내용이 많고 길다.
긴 글 읽다가 지친다, 대충 읽고 대충 답변하거나 그냥 무시한다.&lt;/li&gt;
&lt;li&gt;에티켓이 없다.
10대 언어나 반말을 사용한다. 당신 후배가 저렇게 질문하면 어떤가?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;대부분 &lt;code&gt;1&lt;/code&gt;번 문제를 가지고 있다.&lt;/p&gt;

&lt;h3 id=&#34;1-질문의-내용을-최대한-나누고-디테일하게-서술하기&#34;&gt;1. 질문의 내용을 최대한 나누고 디테일하게 서술하기&lt;/h3&gt;

&lt;p&gt;요점만 정리하여 하나의 요구 사항만 전달해야 한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;저희 학교 커리큘럼 A인데 뭘 듣는 게 좋을까요? &amp;ndash; 확률 10%&lt;/li&gt;
&lt;li&gt;저희 학교 커리큘럼 A인데 B 분야로 가고 싶거든요, 뭐가 좋을까요? &amp;ndash; 확률 70%&lt;/li&gt;
&lt;li&gt;저희 학교 커리큘럼 A인데 B 분야로 가고 싶거든요, C와 D 중에서 어느 것이 더 좋을까요? &amp;ndash; 확률 100%&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt;은 상대방이 당신의 커리큘럼을 확인하는 시간과 비슷한 과목을 걸러내는 시간, 정리하는 시간이 필요하다. 아주 운 좋은 경우 친절한 어느 분이 커리큘럼을 분석하고 과목을 정리한 후 알려준다.&lt;/p&gt;

&lt;h3 id=&#34;2-질문의-요점을-상단-제목에-작성하기&#34;&gt;2. 질문의 요점을 상단/제목에 작성하기&lt;/h3&gt;

&lt;p&gt;요점을 확인하고 당신에게 충고할 수 있는 사람만 클릭하도록 유도를 하는 것이다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;자바 오류 도와주세요!!&lt;/li&gt;
&lt;li&gt;자바 파일 처리 중 A 메서드에서 B 오류가 납니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;2&lt;/code&gt;는 파일 처리 경험이 많은 사람이 당신을 돕는다.&lt;/p&gt;

&lt;h3 id=&#34;3-정보와-방법-제공하기&#34;&gt;3. 정보와 방법 제공하기&lt;/h3&gt;

&lt;p&gt;당신이 연구/공부하는 분야의 환경과 관련된 정보를 제공해야 한다. 또한 상대방이 문제를 쉽게 읽고 분석할 수 있도록 가능한 관련된 링크와 문서 폼을 링크&amp;mdash;Gist/Pastebin나 자신의 개발 환경 정보.&amp;mdash;로 첨부하고 시도했던 방법에 대해 제공해야 한다.&lt;/p&gt;

&lt;h3 id=&#34;4-관련-키워드로-검색하기&#34;&gt;4. 관련 키워드로 검색하기&lt;/h3&gt;

&lt;p&gt;당신이 질문하는 내용 80-90%는 이미 누군가 질문을 한 내용이다. 최대한 검색하고 이해를 한 상태에서 자신의 질문을 작게 나누어 디테일하게 설명해야 한다. 상대방은 당신의 질문만 보고 당신이 관련 키워드로 검색을 했는지 안 했는지 알 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;5-올바른-커뮤니티에서-질문하기&#34;&gt;5. 올바른 커뮤니티에서 질문하기&lt;/h3&gt;

&lt;p&gt;해당 커뮤니티는 그 분야에서 매일 활동하는 분들의 모임이다. 그 외의 주제에 대해 알 수는 있으나 완벽하지 않다. 답변을 받지 못하였다면 자신이 관련 커뮤니티에서 질문했는지 생각해야 한다.&lt;/p&gt;

&lt;p&gt;당신이 질문을 얼마나 신경 써서 하느냐에 따라 답변의 내용도 달라진다. 이것은 선택이 아닌 질문에 대한 에티켓이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;원문 &amp;ndash; Hyun Jun, An&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python - Auto generate requirements.txt</title>
      <link>https://memnoth.github.io/2015/05/18/python-auto-generate-requirements/</link>
      <pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2015/05/18/python-auto-generate-requirements/</guid>
      <description>

&lt;h2 id=&#34;why-requirements-txt&#34;&gt;&lt;em&gt;Why requirements.txt?&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;모든 애플리케이션은 실행될 때 요구하는 종속된 라이브러리들을 가지고 있습니다.&lt;br /&gt;
requirements 파일은 한 번에 어떠한 라이브러리가 종속적인지 확인하고 설치하도록 도와줍니다.&lt;/p&gt;

&lt;h3 id=&#34;requirements-파일-형식&#34;&gt;requirements 파일 형식:&lt;/h3&gt;

&lt;p&gt;&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;requests==1.2.0
Flask==0.10.1
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;방법-1&#34;&gt;방법 1:&lt;/h3&gt;

&lt;p&gt;&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;requirements.txt 파일을 생성하기 위해 pip의 freeze 명령어를 사용합니다.:&lt;br /&gt;
위의 포맷 형식으로 requirements.txt을 생성했다면, &lt;code&gt;pip install -r requirements.txt&lt;/code&gt;로 사용할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;방법-2&#34;&gt;방법 2:&lt;/h3&gt;

&lt;p&gt;pipreqs 사용하기 - pipreqs란 프로젝트에 사용된 패키지만 이용하여 requirements.txt 파일을 생성하는 방법입니다.&lt;/p&gt;

&lt;h4 id=&#34;왜-pip-freeze가-아닌가요&#34;&gt;왜 pip freeze가 아닌가요?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;virtualenv를 사용하지 않는 한 pip freeze는 프로젝트에서 사용하지 않는 패키지도 모두 포함합니다.&lt;/li&gt;
&lt;li&gt;pip freeze는 오로지 당신의 개발 환경에 설치된 패키지들만 사용하여 구성합니다.&lt;/li&gt;
&lt;li&gt;때로는 패키지를 설치하지 않고 requirements.txt를 생성할 필요가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;어떻게-사용하나요&#34;&gt;어떻게 사용하나요?&lt;/h4&gt;

&lt;p&gt;&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pip install pipreqs
$ pipreqs /path/to/project
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;원문 &amp;ndash; &lt;a href=&#34;http://www.idiotinside.com/2015/05/10/python-auto-generate-requirements-txt/&#34; target=&#34;_blank&#34;&gt;Python - Auto generate requirements.txt&lt;/a&gt; (Suresh Kumar)&lt;br /&gt;
번역 &amp;ndash; Hyun Jun, An&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
