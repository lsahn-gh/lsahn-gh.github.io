<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Thomas An</title>
    <link>https://memnoth.github.io/tags/linux/</link>
    <description>Recent content in Linux on Thomas An</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Jun 2017 11:53:39 +0900</lastBuildDate>
    
	<atom:link href="https://memnoth.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to get your Realtek RTL8111/RTL8168 working</title>
      <link>https://memnoth.github.io/2017/06/how-to-get-your-realtek-rtl8111/rtl8168-working/</link>
      <pubDate>Mon, 26 Jun 2017 11:53:39 +0900</pubDate>
      
      <guid>https://memnoth.github.io/2017/06/how-to-get-your-realtek-rtl8111/rtl8168-working/</guid>
      <description>원문 &amp;ndash; How To get your Realtek RTL8111/RTL8168 working by Unixblogger
번역 &amp;ndash; Yi Soo, (Thomas) An
Why do I need this driver anyway? 많은 분들이 제게 &amp;ldquo;이게 왜 필요하죠? 리눅스에서 지원하지 않나요?&amp;hellip;&amp;rdquo; 라고 물어봅니다. 하지만 RTL8111/RTL8168은 오픈 소스가 아니에요. 이제 왜 리눅스 커널에 포함되지 않는지 아시겠죠?
그래서 우리가 직접 빌드해야 된답니다.
The installation methods Ubuntu/Debian에서 디바이스 드라이버를 컴파일하는 방법에 대해 글을 쓴 이후로 많은 것이 변했습니다. 그래서 오늘은 드라이버를 설치하기 위한 방법 2개를 소개하고자 합니다.</description>
    </item>
    
    <item>
      <title>YouCompleteMe - libtinfo.so.5 not found</title>
      <link>https://memnoth.github.io/2016/07/youcompleteme---libtinfo.so.5-not-found/</link>
      <pubDate>Sun, 24 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2016/07/youcompleteme---libtinfo.so.5-not-found/</guid>
      <description>Laptop에 Fedora 24를 설치하고 YouCompleteMe1를 인스톨했으나 SHUTTING DOWN 오류를 출력하며 정상적으로 실행되지 않았다.
:YcmToggleLogs stderr를 통하여 디버깅을 해보니 시스템에서 libtinfo.so.52를 찾지 못해 발생한 예외였다.
설치된 패키지가 있나 확인해보니 6.0.5 버전으로 존재했다.
$ dnf list installed | grep ncurses ncurses.x86_64 6.0-5.20160116.fc24 @koji-override-0 ncurses-base.noarch 6.0-5.20160116.fc24 @koji-override-0 ncurses-libs.x86_64 6.0-5.20160116.fc24 @koji-override-0  lib64 디렉터리에서도 libtinfo.so.6을 찾을 수 있다, 나는 libtinfo.so.5를 원하는데&amp;hellip;
$ ls -l /lib64/libtinfo* lrwxrwxrwx. 1 root root 15 4월 8 19:33 /lib64/libtinfo.so.6 -&amp;gt; libtinfo.</description>
    </item>
    
    <item>
      <title>비글본 블랙에서의 Dynamic Linking 오류</title>
      <link>https://memnoth.github.io/2016/06/%EB%B9%84%EA%B8%80%EB%B3%B8-%EB%B8%94%EB%9E%99%EC%97%90%EC%84%9C%EC%9D%98-dynamic-linking-%EC%98%A4%EB%A5%98/</link>
      <pubDate>Fri, 24 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2016/06/%EB%B9%84%EA%B8%80%EB%B3%B8-%EB%B8%94%EB%9E%99%EC%97%90%EC%84%9C%EC%9D%98-dynamic-linking-%EC%98%A4%EB%A5%98/</guid>
      <description>임베디드 시스템에선 코드 작성 및 컴파일을 빠르게 하기 위해 Host PC와 Target board를 NFS로 연결하여 Host PC에서 컴파일 작업을 하고, Target board에서는 실행시키는 구조로 개발환경을 빌드한다.
NFS 개발환경을 설정한 다음 arm gcc를 이용하여 컴파일을 했음에도 불구하고 No such file or directory 오류가 발생하였다.
계정 권한, 파일 권한, Host PC의 mount 권한까지 모두 확인하였지만 잘못된 부분이 없었기에 무척 난감했는데 Dynamic Linking이 원인이였다.
test가 실행파일이라 가정하고 file 명령어를 이용하여 확인해보자.
test: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description>
    </item>
    
    <item>
      <title>mmap을 이용하여 GPIO 제어하기 - #1. Clock Enabling</title>
      <link>https://memnoth.github.io/2016/05/mmap%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-gpio-%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0---#1.-clock-enabling/</link>
      <pubDate>Thu, 19 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2016/05/mmap%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-gpio-%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0---#1.-clock-enabling/</guid>
      <description>아래 가이드는 C 언어와 Linux에 능숙하고 Computer Organization, Microprocessor를 수강한 적 있는 학부생에게 추천합니다.! 왜 mmap을 이용하여 direct로 접근하나요?  The memory-mapping method allows you to directly access the registors that control the
GPIOs. Memory-mapping is very fast (about 1000 times faster than file I/O!), but only
processes with root permissions can use it.
 책1에 따르면 memory-mapping 함수는 register에 직접 접근하도록 하며, 이는 file I/O 방식보다 1000배는 빠르다고 합니다.</description>
    </item>
    
    <item>
      <title>Convert encoding of Documents in Linux</title>
      <link>https://memnoth.github.io/2015/05/convert-encoding-of-documents-in-linux/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://memnoth.github.io/2015/05/convert-encoding-of-documents-in-linux/</guid>
      <description>Introduce 리눅스에서 문서를 읽을때 euc-kr로 저장된 파일을 읽으면 깨진다. 리눅스는 기본이 utf-8이기 때문에 euc-kr 파일을 읽으려면 수작업으로 인코딩을 변경하고 읽어야 하는데 이 작업이 여간 따분하고 귀찮다. 특히 미드/영드/일드를 볼때 ..
그래서 인코딩을 변경하는 쉘 스크립트를 작성하고 alias로 등록하여 빠르게 변경하기로 했다.
 
 스크립트를 vi/vim으로 작성하고 conv2utf8로 ~/Documents에 저장한다.
 .bash_aliases파일을 열고 alias c8=&#39;$HOME/Documents/conv2utf8&#39;로 저장한다.
 source ~/.bashrc로 쉘을 다시 로드한 뒤 c8 /path/to/directory/로 사용한다.</description>
    </item>
    
  </channel>
</rss>